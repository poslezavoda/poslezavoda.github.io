<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TgPosted - Водяные знаки для Telegram</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #0072ff, #00c6ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .header p {
            color: #666;
            font-size: 16px;
        }

        .steps-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            position: relative;
        }

        .steps-indicator::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 10%;
            right: 10%;
            height: 3px;
            background: #e0e0e0;
            z-index: 1;
        }

        .step {
            position: relative;
            z-index: 2;
            text-align: center;
            flex: 1;
        }

        .step-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e0e0e0;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            margin: 0 auto 10px;
            transition: all 0.3s;
        }

        .step.active .step-circle {
            background: linear-gradient(90deg, #0072ff, #00c6ff);
            color: white;
            transform: scale(1.1);
        }

        .step.completed .step-circle {
            background: #4CAF50;
            color: white;
        }

        .step-text {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        .step.active .step-text {
            color: #0072ff;
            font-weight: 600;
        }

        .card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s;
        }

        .card-title {
            font-size: 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #333;
        }

        .card-title i {
            color: #0072ff;
        }

        .step-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .step-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .upload-area {
            border: 2px dashed rgba(0, 114, 255, 0.3);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
            background: #f8f9fa;
        }

        .upload-area:hover {
            border-color: #0072ff;
            background: rgba(0, 114, 255, 0.03);
        }

        .upload-icon {
            font-size: 48px;
            color: #0072ff;
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 18px;
            margin-bottom: 10px;
            color: #333;
        }

        .upload-subtext {
            color: #666;
            font-size: 14px;
        }

        .preview-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
        }

        .preview-title {
            font-size: 18px;
            margin-bottom: 15px;
            color: #666;
            align-self: flex-start;
        }

        #mediaPreview, #processedMediaPreview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            object-fit: contain;
            background-color: #f8f9fa;
        }

        #videoPreview, #processedVideoPreview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            background-color: #000;
            object-fit: contain;
        }

        .video-container {
            width: 100%;
            max-width: 500px;
            position: relative;
            background-color: #000;
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto;
        }

        .video-container video {
            width: 100%;
            height: auto;
            display: block;
        }

        .change-media-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
        }

        .change-media-btn:hover {
            background: #0072ff;
            color: white;
            transform: scale(1.1);
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-size: 16px;
            font-weight: 500;
            color: #444;
        }

        select, input[type="text"], input[type="range"], input[type="number"] {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 16px;
            color: #333;
            font-size: 16px;
            outline: none;
            transition: all 0.3s;
        }

        select:focus, input[type="text"]:focus, input[type="number"]:focus {
            border-color: #0072ff;
            box-shadow: 0 0 0 2px rgba(0, 114, 255, 0.1);
        }

        input[type="range"] {
            padding: 8px 0;
            background: transparent;
        }

        .range-value {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
        }

        .watermark-type {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .type-option {
            flex: 1;
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid #e0e0e0;
            color: #666;
        }

        .type-option.active {
            background: rgba(0, 114, 255, 0.1);
            border-color: #0072ff;
            color: #0072ff;
        }

        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .position-btn {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid #e0e0e0;
            color: #666;
        }

        .position-btn.active {
            background: rgba(0, 114, 255, 0.1);
            border-color: #0072ff;
            color: #0072ff;
        }

        .position-btn i {
            font-size: 20px;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e0e0e0;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #0072ff;
        }

        input:checked + .slider:before {
            transform: translateX(30px);
        }

        .motion-settings {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            display: none;
            border: 1px solid #e0e0e0;
        }

        .motion-settings.active {
            display: block;
        }

        .motion-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            padding: 16px 24px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #0072ff, #00c6ff);
            color: white;
            flex: 1;
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #e0e0e0;
        }

        .btn-success {
            background: linear-gradient(90deg, #4CAF50, #45a049);
            color: white;
            min-width: 250px;
            margin: 0 auto;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 114, 255, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(0, 114, 255, 0.1);
            border-top-color: #0072ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .processing-text {
            font-size: 20px;
            color: #333;
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            color: #666;
            font-size: 14px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .hidden {
            display: none !important;
        }

        .media-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            text-align: center;
        }

        .result-actions {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .download-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        /* Стили для сохраненных водяных знаков */
        .saved-watermarks {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .saved-watermarks-title {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .saved-watermarks-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .saved-watermark-item {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
            text-align: center;
            position: relative;
        }

        .saved-watermark-item:hover {
            border-color: #0072ff;
            transform: translateY(-2px);
        }

        .saved-watermark-item.active {
            border-color: #0072ff;
            background: rgba(0, 114, 255, 0.1);
        }

        .saved-watermark-preview {
            width: 80px;
            height: 40px;
            object-fit: contain;
            margin-bottom: 8px;
            border-radius: 4px;
        }

        .saved-watermark-text {
            font-size: 12px;
            color: #333;
            word-break: break-all;
            max-height: 36px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-watermark-actions {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 10px;
        }

        .delete-watermark-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
        }

        .save-current-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 15px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .save-current-btn:hover {
            background: #e9ecef;
            border-color: #0072ff;
        }

        /* Стили для выбора цвета */
        .color-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .color-option-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-option-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            color: #444;
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            background: transparent;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: 2px solid #e0e0e0;
            border-radius: 6px;
        }

        .color-value {
            font-size: 14px;
            color: #666;
            min-width: 80px;
        }

        .color-presets {
            display: flex;
            gap: 8px;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        .color-preset {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid #e0e0e0;
            transition: all 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
            border-color: #0072ff;
        }

        .color-preset.active {
            border-color: #0072ff;
            transform: scale(1.1);
            box-shadow: 0 0 0 2px rgba(0, 114, 255, 0.2);
        }

        /* Улучшенные настройки движения */
        .motion-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
        }

        .motion-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .motion-preset {
            padding: 12px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 14px;
        }

        .motion-preset:hover {
            border-color: #0072ff;
            transform: translateY(-2px);
        }

        .motion-preset.active {
            background: rgba(0, 114, 255, 0.1);
            border-color: #0072ff;
            color: #0072ff;
        }

        .motion-preview {
            width: 100%;
            height: 80px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
            border: 1px solid #e0e0e0;
        }

        .motion-preview-watermark {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #0072ff;
            border-radius: 4px;
            opacity: 0.7;
        }

        /* Новые стили для прогресса обработки видео */
        .video-processing-container {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            display: none;
        }

        .video-processing-container.active {
            display: block;
        }

        .video-processing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .video-processing-title {
            font-size: 16px;
            color: #333;
            font-weight: 600;
        }

        .video-processing-percentage {
            font-size: 16px;
            color: #0072ff;
            font-weight: bold;
        }

        .video-processing-progress {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .video-processing-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0072ff, #00c6ff);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .video-processing-stats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .video-processing-time {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }

        .video-processing-cancel {
            margin-top: 10px;
            display: flex;
            justify-content: center;
        }

        /* Стили для мобильного сохранения файлов */
        .save-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Новый стиль для отображения пути сохранения */
        .save-path-info {
            background: #e8f5e8;
            border: 1px solid #4CAF50;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: none;
        }

        .save-path-info.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .save-path-title {
            font-size: 16px;
            color: #2E7D32;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .save-path-text {
            font-size: 14px;
            color: #333;
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            word-break: break-all;
            font-family: monospace;
            margin-bottom: 10px;
        }

        .save-path-copy-btn {
            background: #0072ff;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .save-path-copy-btn:hover {
            background: #0056cc;
        }

        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            
            .card {
                padding: 16px;
            }
            
            .motion-controls {
                grid-template-columns: 1fr;
            }
            
            .navigation-buttons {
                flex-direction: column;
            }
            
            .steps-indicator {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .step {
                flex: none;
                width: 30%;
            }
            
            #mediaPreview, #processedMediaPreview, 
            #videoPreview, #processedVideoPreview {
                max-height: 300px;
            }
            
            .btn-success {
                min-width: 200px;
                width: 100%;
                max-width: 300px;
            }
            
            .saved-watermarks-list {
                justify-content: center;
            }
            
            .saved-watermark-item {
                min-width: 100px;
                padding: 8px;
            }
            
            .color-presets {
                justify-content: center;
            }
            
            .motion-presets {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .save-options {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-paperclip"></i> TgPosted</h1>
            <p>Наложение водяных знаков на фото и видео для Telegram</p>
        </div>

        <!-- Индикатор шагов -->
        <div class="steps-indicator">
            <div class="step active" id="step1">
                <div class="step-circle">1</div>
                <div class="step-text">Создание вотермарки</div>
            </div>
            <div class="step" id="step2">
                <div class="step-circle">2</div>
                <div class="step-text">Загрузка медиа</div>
            </div>
            <div class="step" id="step3">
                <div class="step-circle">3</div>
                <div class="step-text">Результат</div>
            </div>
        </div>

        <!-- Шаг 1: Создание вотермарки -->
        <div class="card step-content active" id="step1Content">
            <h2 class="card-title"><i class="fas fa-paint-brush"></i> Создание водяного знака</h2>
            
            <!-- Сохраненные водяные знаки -->
            <div class="saved-watermarks">
                <h3 class="saved-watermarks-title">
                    <i class="fas fa-bookmark"></i> Мои сохранённые водяные знаки
                </h3>
                <div class="saved-watermarks-list" id="savedWatermarksList">
                    <!-- Будут загружаться из localStorage -->
                </div>
                <div class="save-current-btn" id="saveCurrentWatermarkBtn">
                    <i class="fas fa-save"></i>
                    <span>Сохранить текущий водяной знак</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Тип водяного знака:</label>
                    <div class="watermark-type">
                        <div class="type-option active" id="textTypeOption">
                            <i class="fas fa-font"></i> Текст
                        </div>
                        <div class="type-option" id="imageTypeOption">
                            <i class="fas fa-image"></i> Изображение
                        </div>
                    </div>
                </div>

                <div class="control-group" id="textWatermarkControl">
                    <label for="watermarkText">Текст водяного знака:</label>
                    <input type="text" id="watermarkText" placeholder="Например: @ваш_канал" value="@TgPosted">
                    
                    <!-- Выбор цвета текста -->
                    <div class="color-options">
                        <div class="color-option-group">
                            <div class="color-option-label">
                                <span>Цвет текста:</span>
                                <span class="color-value" id="textColorValue">#FFFFFF</span>
                            </div>
                            <div class="color-picker-container">
                                <input type="color" id="textColorPicker" class="color-picker" value="#FFFFFF">
                                <div class="color-presets" id="textColorPresets">
                                    <!-- Цвета будут добавлены через JavaScript -->
                                </div>
                            </div>
                        </div>
                        
                        <div class="color-option-group">
                            <div class="color-option-label">
                                <span>Цвет обводки:</span>
                                <span class="color-value" id="strokeColorValue">#000000</span>
                            </div>
                            <div class="color-picker-container">
                                <input type="color" id="strokeColorPicker" class="color-picker" value="#000000">
                                <div class="color-presets" id="strokeColorPresets">
                                    <!-- Цвета будут добавлены через JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="control-group hidden" id="imageWatermarkControl">
                    <label>Загрузите изображение водяного знака:</label>
                    <div class="upload-area" id="watermarkUploadArea" style="padding: 20px;">
                        <div class="upload-icon" style="font-size: 32px;">
                            <i class="fas fa-file-image"></i>
                        </div>
                        <div class="upload-text" style="font-size: 14px;">Загрузить изображение</div>
                        <input type="file" id="watermarkImageInput" accept="image/*" class="hidden">
                    </div>
                    <img id="watermarkImagePreview" class="hidden" style="max-width: 100px; max-height: 100px; margin-top: 10px; border-radius: 5px;">
                </div>

                <div class="control-group">
                    <label for="opacitySlider">Прозрачность: <span id="opacityValue">70%</span></label>
                    <input type="range" id="opacitySlider" min="10" max="100" value="70">
                    <div class="range-value">
                        <span>Слабая</span>
                        <span>Яркая</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Позиция водяного знака:</label>
                    <div class="position-grid">
                        <div class="position-btn active" data-position="top-left">
                            <i class="fas fa-arrow-up-left"></i>
                        </div>
                        <div class="position-btn" data-position="top-center">
                            <i class="fas fa-arrow-up"></i>
                        </div>
                        <div class="position-btn" data-position="top-right">
                            <i class="fas fa-arrow-up-right"></i>
                        </div>
                        <div class="position-btn" data-position="center-left">
                            <i class="fas fa-arrow-left"></i>
                        </div>
                        <div class="position-btn" data-position="center">
                            <i class="fas fa-circle"></i>
                        </div>
                        <div class="position-btn" data-position="center-right">
                            <i class="fas fa-arrow-right"></i>
                        </div>
                        <div class="position-btn" data-position="bottom-left">
                            <i class="fas fa-arrow-down-left"></i>
                        </div>
                        <div class="position-btn" data-position="bottom-center">
                            <i class="fas fa-arrow-down"></i>
                        </div>
                        <div class="position-btn" data-position="bottom-right">
                            <i class="fas fa-arrow-down-right"></i>
                        </div>
                    </div>
                </div>

                <!-- Настройки движения водяного знака (всегда видны) -->
                <div class="control-group motion-options">
                    <label>Настройки движения для видео:</label>
                    <div class="toggle-switch">
                        <span>Подвижная водяная марка</span>
                        <label class="switch">
                            <input type="checkbox" id="movingWatermark">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="motion-settings" id="motionSettings">
                        <div class="motion-controls">
                            <div>
                                <label for="speedSlider">Скорость движения: <span id="speedValue">5</span></label>
                                <input type="range" id="speedSlider" min="1" max="20" value="5">
                                <div class="range-value">
                                    <span>Медленно</span>
                                    <span>Быстро</span>
                                </div>
                            </div>
                            
                            <div>
                                <label for="motionType">Тип движения:</label>
                                <select id="motionType">
                                    <option value="bounce">Отскок от краев</option>
                                    <option value="circular">Круговое</option>
                                    <option value="horizontal">Горизонтальное</option>
                                    <option value="vertical">Вертикальное</option>
                                    <option value="diagonal">Диагональное</option>
                                    <option value="spiral">Спиральное</option>
                                    <option value="random">Случайное</option>
                                    <option value="wave">Волнообразное</option>
                                    <option value="figure8">Восьмерка</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="motion-presets" id="motionPresets">
                            <!-- Пресеты движения будут добавлены через JavaScript -->
                        </div>
                        
                        <div class="motion-preview" id="motionPreview">
                            <div class="motion-preview-watermark" id="motionPreviewWatermark"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="navigation-buttons">
                <button class="btn btn-secondary" id="resetAllBtn">
                    <i class="fas fa-redo"></i> Сбросить всё
                </button>
                <button class="btn btn-primary" id="nextToStep2">
                    Далее: Загрузить медиа <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>

        <!-- Шаг 2: Загрузка медиа -->
        <div class="card step-content" id="step2Content">
            <h2 class="card-title"><i class="fas fa-upload"></i> Загрузка медиа</h2>
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">
                    <i class="fas fa-cloud-upload-alt"></i>
                </div>
                <div class="upload-text">Нажмите для загрузки фото или видео</div>
                <div class="upload-subtext">Поддерживаются форматы: JPG, PNG, GIF, MP4, WEBM, MOV</div>
                <input type="file" id="fileInput" accept="image/*,video/*" class="hidden">
            </div>

            <div class="preview-container">
                <div class="preview-title">Предпросмотр медиа:</div>
                
                <!-- Контейнер для видео -->
                <div class="video-container hidden" id="videoContainer">
                    <video id="videoPreview" controls></video>
                </div>
                
                <!-- Изображение -->
                <img id="mediaPreview" class="hidden">
                
                <div id="noPreview" class="preview-title" style="text-align: center; width: 100%; padding: 40px 0; color: #999;">
                    <i class="fas fa-image" style="font-size: 48px; margin-bottom: 15px; display: block;"></i>
                    Медиафайл не загружен
                </div>
                
                <button class="change-media-btn hidden" id="changeMediaBtn" title="Заменить медиа">
                    <i class="fas fa-exchange-alt"></i>
                </button>
                
                <div id="mediaInfo" class="media-info hidden"></div>
            </div>

            <!-- Контейнер для прогресса обработки видео -->
            <div class="video-processing-container" id="videoProcessingContainer">
                <div class="video-processing-header">
                    <div class="video-processing-title">
                        <i class="fas fa-video"></i> Обработка видео
                    </div>
                    <div class="video-processing-percentage" id="videoProcessingPercentage">0%</div>
                </div>
                <div class="video-processing-progress">
                    <div class="video-processing-progress-bar" id="videoProcessingProgressBar"></div>
                </div>
                <div class="video-processing-stats">
                    <span>Обработано кадров: <span id="processedFrames">0</span> из <span id="totalFrames">0</span></span>
                    <span id="processingSpeed">0 кадр/сек</span>
                </div>
                <div class="video-processing-time" id="videoProcessingTime">Осталось: расчет...</div>
                <div class="video-processing-cancel">
                    <button class="btn btn-secondary btn-small" id="cancelVideoProcessingBtn">
                        <i class="fas fa-stop"></i> Отменить обработку
                    </button>
                </div>
            </div>

            <div class="navigation-buttons">
                <button class="btn btn-secondary" id="backToStep1">
                    <i class="fas fa-arrow-left"></i> Назад
                </button>
                <button class="btn btn-primary" id="applyWatermarkBtn" disabled>
                    <i class="fas fa-magic"></i> Наложить водяной знак
                </button>
            </div>
        </div>

        <!-- Шаг 3: Результат -->
        <div class="card step-content" id="step3Content">
            <h2 class="card-title"><i class="fas fa-check-circle"></i> Результат</h2>
            
            <div class="preview-container">
                <div class="preview-title">Обработанное медиа:</div>
                
                <!-- Контейнер для обработанного видео -->
                <div class="video-container hidden" id="processedVideoContainer">
                    <video id="processedVideoPreview" controls></video>
                </div>
                
                <!-- Обработанное изображение -->
                <img id="processedMediaPreview" class="hidden">
                
                <div id="noProcessedPreview" class="preview-title" style="text-align: center; width: 100%; padding: 40px 0; color: #999;">
                    <i class="fas fa-water" style="font-size: 48px; margin-bottom: 15px; display: block;"></i>
                    Водяной знак ещё не наложен
                </div>
            </div>

            <!-- Центрированная кнопка загрузки -->
            <div class="download-container">
                <button class="btn btn-success" id="downloadResultBtn" disabled>
                    <i class="fas fa-download"></i> Скачать результат
                </button>
            </div>

            <!-- Опции сохранения для мобильных устройств -->
            <div class="save-options hidden" id="saveOptions">
                <button class="btn btn-primary" id="saveToGalleryBtn">
                    <i class="fas fa-save"></i> Сохранить в галерею
                </button>
                <button class="btn btn-secondary" id="shareFileBtn">
                    <i class="fas fa-share"></i> Поделиться файлом
                </button>
            </div>

            <!-- Информация о сохраненном пути -->
            <div class="save-path-info" id="savePathInfo">
                <div class="save-path-title">
                    <i class="fas fa-check-circle"></i> Файл успешно сохранен!
                </div>
                <div class="save-path-text" id="savePathText">
                    Путь будет показан здесь после сохранения
                </div>
                <button class="save-path-copy-btn" id="copyPathBtn">
                    <i class="fas fa-copy"></i> Копировать путь
                </button>
            </div>

            <div class="navigation-buttons">
                <button class="btn btn-secondary" id="backToStep2">
                    <i class="fas fa-arrow-left"></i> Назад к загрузке
                </button>
                <button class="btn btn-primary" id="processNewBtn">
                    <i class="fas fa-plus"></i> Обработать новый файл
                </button>
            </div>
        </div>

        <div class="footer">
            <p>Вся обработка происходит на вашем устройстве. Качество и FPS видео сохраняются.</p>
            <p style="margin-top: 10px;">Для работы с Telegram: добавьте этот код в мини-приложение через BotFather</p>
        </div>
    </div>

    <div class="processing-overlay" id="processingOverlay">
        <div class="spinner"></div>
        <div class="processing-text" id="processingText">Обработка...</div>
    </div>

    <script>
        // Инициализация Telegram Web App
        let tg = window.Telegram.WebApp;
        tg.expand();
        tg.enableClosingConfirmation();
        
        // Элементы DOM для шагов
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const step1Content = document.getElementById('step1Content');
        const step2Content = document.getElementById('step2Content');
        const step3Content = document.getElementById('step3Content');
        
        // Элементы для навигации
        const nextToStep2Btn = document.getElementById('nextToStep2');
        const backToStep1Btn = document.getElementById('backToStep1');
        const backToStep2Btn = document.getElementById('backToStep2');
        const applyWatermarkBtn = document.getElementById('applyWatermarkBtn');
        const processNewBtn = document.getElementById('processNewBtn');
        const resetAllBtn = document.getElementById('resetAllBtn');
        
        // Элементы для водяного знака (из Шага 1)
        const watermarkText = document.getElementById('watermarkText');
        const watermarkImageInput = document.getElementById('watermarkImageInput');
        const watermarkUploadArea = document.getElementById('watermarkUploadArea');
        const watermarkImagePreview = document.getElementById('watermarkImagePreview');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const positionButtons = document.querySelectorAll('.position-btn');
        const textTypeOption = document.getElementById('textTypeOption');
        const imageTypeOption = document.getElementById('imageTypeOption');
        const textWatermarkControl = document.getElementById('textWatermarkControl');
        const imageWatermarkControl = document.getElementById('imageWatermarkControl');
        
        // Элементы для цвета текста
        const textColorPicker = document.getElementById('textColorPicker');
        const textColorValue = document.getElementById('textColorValue');
        const textColorPresets = document.getElementById('textColorPresets');
        const strokeColorPicker = document.getElementById('strokeColorPicker');
        const strokeColorValue = document.getElementById('strokeColorValue');
        const strokeColorPresets = document.getElementById('strokeColorPresets');
        
        // Элементы для движения
        const movingWatermark = document.getElementById('movingWatermark');
        const motionSettings = document.getElementById('motionSettings');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const motionType = document.getElementById('motionType');
        const motionPresets = document.getElementById('motionPresets');
        const motionPreview = document.getElementById('motionPreview');
        const motionPreviewWatermark = document.getElementById('motionPreviewWatermark');
        
        // Элементы для загрузки медиа (из Шага 2)
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const mediaPreview = document.getElementById('mediaPreview');
        const videoPreview = document.getElementById('videoPreview');
        const videoContainer = document.getElementById('videoContainer');
        const noPreview = document.getElementById('noPreview');
        const changeMediaBtn = document.getElementById('changeMediaBtn');
        const mediaInfo = document.getElementById('mediaInfo');
        
        // Элементы для прогресса обработки видео
        const videoProcessingContainer = document.getElementById('videoProcessingContainer');
        const videoProcessingPercentage = document.getElementById('videoProcessingPercentage');
        const videoProcessingProgressBar = document.getElementById('videoProcessingProgressBar');
        const processedFrames = document.getElementById('processedFrames');
        const totalFrames = document.getElementById('totalFrames');
        const processingSpeed = document.getElementById('processingSpeed');
        const videoProcessingTime = document.getElementById('videoProcessingTime');
        const cancelVideoProcessingBtn = document.getElementById('cancelVideoProcessingBtn');
        
        // Элементы для результата (из Шага 3)
        const processedMediaPreview = document.getElementById('processedMediaPreview');
        const processedVideoPreview = document.getElementById('processedVideoPreview');
        const processedVideoContainer = document.getElementById('processedVideoContainer');
        const noProcessedPreview = document.getElementById('noProcessedPreview');
        const downloadResultBtn = document.getElementById('downloadResultBtn');
        
        // Элементы для сохранения файлов
        const saveOptions = document.getElementById('saveOptions');
        const saveToGalleryBtn = document.getElementById('saveToGalleryBtn');
        const shareFileBtn = document.getElementById('shareFileBtn');
        
        // Элементы для сохраненного пути
        const savePathInfo = document.getElementById('savePathInfo');
        const savePathText = document.getElementById('savePathText');
        const copyPathBtn = document.getElementById('copyPathBtn');
        
        // Элементы для сохраненных водяных знаков
        const savedWatermarksList = document.getElementById('savedWatermarksList');
        const saveCurrentWatermarkBtn = document.getElementById('saveCurrentWatermarkBtn');
        
        // Дополнительные элементы
        const processingOverlay = document.getElementById('processingOverlay');
        const processingText = document.getElementById('processingText');
        
        // Переменные состояния
        let currentStep = 1;
        let originalMedia = null;
        let processedMedia = null;
        let watermarkType = 'text';
        let watermarkImage = null;
        let position = 'bottom-right';
        let isVideo = false;
        let videoFrames = [];
        let videoDuration = 0;
        let originalFormat = '';
        let originalFileName = '';
        let savedWatermarks = [];
        
        // Переменные для обработки видео
        let videoProcessingActive = false;
        let videoProcessingStartTime = 0;
        let lastUpdateTime = 0;
        let framesProcessed = 0;
        let totalVideoFrames = 0;
        let currentMediaRecorder = null;
        
        // Цвета по умолчанию
        let textColor = '#FFFFFF';
        let strokeColor = '#000000';
        
        // Состояние водяного знака для движения
        let watermarkState = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            videoWidth: 0,
            videoHeight: 0,
            speed: 1,
            motionType: 'bounce',
            time: 0,
            amplitude: 100,
            frequency: 0.5,
            pathPoints: []
        };
        
        // Анимация предпросмотра движения
        let motionPreviewAnimation = null;
        let motionPreviewStartTime = 0;
        
        // Предустановленные цвета
        const colorPresets = {
            textColors: [
                '#FFFFFF', '#000000', '#FF0000', '#00FF00', '#0000FF',
                '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080',
                '#008000', '#FFC0CB', '#A52A2A', '#808080', '#FFD700'
            ],
            strokeColors: [
                '#000000', '#FFFFFF', '#333333', '#666666', '#999999',
                '#CCCCCC', '#FF0000', '#00FF00', '#0000FF', '#FFA500'
            ]
        };
        
        // Пресеты движения
        const motionPresetsData = [
            { name: 'Медленное плавание', speed: 3, type: 'bounce', amplitude: 50, frequency: 0.3 },
            { name: 'Быстрое кружение', speed: 8, type: 'circular', amplitude: 100, frequency: 1 },
            { name: 'Плавное по горизонтали', speed: 4, type: 'horizontal', amplitude: 80, frequency: 0.4 },
            { name: 'Плавное по вертикали', speed: 4, type: 'vertical', amplitude: 80, frequency: 0.4 },
            { name: 'Диагональный дрейф', speed: 5, type: 'diagonal', amplitude: 70, frequency: 0.5 },
            { name: 'Спиральный полет', speed: 6, type: 'spiral', amplitude: 120, frequency: 0.8 },
            { name: 'Случайный патруль', speed: 7, type: 'random', amplitude: 90, frequency: 0.6 },
            { name: 'Волнообразное', speed: 5, type: 'wave', amplitude: 60, frequency: 0.7 },
            { name: 'Восьмерка', speed: 6, type: 'figure8', amplitude: 80, frequency: 0.5 }
        ];
        
        // Инициализация
        init();
        
        function init() {
            // Загружаем сохраненные водяные знаки
            loadSavedWatermarks();
            
            // Инициализируем выбор цвета
            initColorPickers();
            
            // Инициализируем пресеты движения
            initMotionPresets();
            
            // Инициализируем предпросмотр движения
            initMotionPreview();
            
            // Проверяем, мобильное ли устройство
            checkMobileDevice();
            
            // Навигация по шагам
            nextToStep2Btn.addEventListener('click', () => goToStep(2));
            backToStep1Btn.addEventListener('click', () => goToStep(1));
            backToStep2Btn.addEventListener('click', () => goToStep(2));
            applyWatermarkBtn.addEventListener('click', applyWatermark);
            processNewBtn.addEventListener('click', () => goToStep(2));
            resetAllBtn.addEventListener('click', resetAll);
            
            // Загрузка медиа (Шаг 2)
            uploadArea.addEventListener('click', () => fileInput.click());
            changeMediaBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleMediaUpload);
            
            // Настройки водяного знака (Шаг 1)
            textTypeOption.addEventListener('click', () => setWatermarkType('text'));
            imageTypeOption.addEventListener('click', () => setWatermarkType('image'));
            watermarkUploadArea.addEventListener('click', () => watermarkImageInput.click());
            watermarkImageInput.addEventListener('change', handleWatermarkImageUpload);
            
            opacitySlider.addEventListener('input', () => {
                opacityValue.textContent = `${opacitySlider.value}%`;
            });
            
            positionButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    positionButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    position = btn.dataset.position;
                });
            });
            
            // Настройки движения
            movingWatermark.addEventListener('change', () => {
                if (movingWatermark.checked) {
                    motionSettings.classList.add('active');
                    startMotionPreview();
                } else {
                    motionSettings.classList.remove('active');
                    stopMotionPreview();
                }
            });
            
            speedSlider.addEventListener('input', () => {
                speedValue.textContent = speedSlider.value;
            });
            
            motionType.addEventListener('change', () => {
                // Обновляем предпросмотр при изменении типа движения
                if (movingWatermark.checked) {
                    startMotionPreview();
                }
            });
            
            // Обработка видео
            cancelVideoProcessingBtn.addEventListener('click', cancelVideoProcessing);
            
            // Сохранение водяного знака
            saveCurrentWatermarkBtn.addEventListener('click', saveCurrentWatermark);
            
            // Скачивание и сохранение результата
            downloadResultBtn.addEventListener('click', handleDownload);
            saveToGalleryBtn.addEventListener('click', saveToGallery);
            shareFileBtn.addEventListener('click', shareFile);
            copyPathBtn.addEventListener('click', copyPathToClipboard);
        }
        
        function checkMobileDevice() {
            // Проверяем, является ли устройство мобильным
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Показываем опции сохранения для мобильных устройств
            if (isMobile) {
                saveOptions.classList.remove('hidden');
            }
        }
        
        function initColorPickers() {
            // Устанавливаем начальные значения
            textColorPicker.value = textColor;
            strokeColorPicker.value = strokeColor;
            
            // Обновляем отображаемые значения
            updateColorValues();
            
            // Создаем пресеты цветов для текста
            colorPresets.textColors.forEach(color => {
                const preset = document.createElement('div');
                preset.className = 'color-preset';
                preset.style.backgroundColor = color;
                preset.dataset.color = color;
                preset.title = color;
                
                preset.addEventListener('click', () => {
                    textColorPicker.value = color;
                    textColor = color;
                    updateColorValues();
                    highlightPreset(preset, textColorPresets);
                });
                
                textColorPresets.appendChild(preset);
            });
            
            // Создаем пресеты цветов для обводки
            colorPresets.strokeColors.forEach(color => {
                const preset = document.createElement('div');
                preset.className = 'color-preset';
                preset.style.backgroundColor = color;
                preset.dataset.color = color;
                preset.title = color;
                
                preset.addEventListener('click', () => {
                    strokeColorPicker.value = color;
                    strokeColor = color;
                    updateColorValues();
                    highlightPreset(preset, strokeColorPresets);
                });
                
                strokeColorPresets.appendChild(preset);
            });
            
            // Обработчики для цветовых пикеров
            textColorPicker.addEventListener('input', (e) => {
                textColor = e.target.value;
                updateColorValues();
                highlightPresetByColor(textColor, textColorPresets);
            });
            
            strokeColorPicker.addEventListener('input', (e) => {
                strokeColor = e.target.value;
                updateColorValues();
                highlightPresetByColor(strokeColor, strokeColorPresets);
            });
            
            // Выделяем пресеты по умолчанию
            highlightPresetByColor(textColor, textColorPresets);
            highlightPresetByColor(strokeColor, strokeColorPresets);
        }
        
        function initMotionPresets() {
            motionPresetsData.forEach((preset, index) => {
                const presetElement = document.createElement('div');
                presetElement.className = 'motion-preset';
                presetElement.dataset.index = index;
                presetElement.textContent = preset.name;
                
                presetElement.addEventListener('click', () => {
                    // Устанавливаем значения пресета
                    speedSlider.value = preset.speed;
                    speedValue.textContent = preset.speed;
                    motionType.value = preset.type;
                    
                    // Активируем подвижную водяную марку, если еще не активирована
                    if (!movingWatermark.checked) {
                        movingWatermark.checked = true;
                        motionSettings.classList.add('active');
                        startMotionPreview();
                    }
                    
                    // Выделяем выбранный пресет
                    document.querySelectorAll('.motion-preset').forEach(p => {
                        p.classList.remove('active');
                    });
                    presetElement.classList.add('active');
                    
                    // Обновляем предпросмотр
                    startMotionPreview();
                    
                    tg.HapticFeedback.impactOccurred('light');
                });
                
                motionPresets.appendChild(presetElement);
            });
        }
        
        function initMotionPreview() {
            // Начальная позиция для предпросмотра
            watermarkState.width = 30;
            watermarkState.height = 30;
            
            // Обновляем размеры при изменении окна
            window.addEventListener('resize', () => {
                if (motionPreviewAnimation) {
                    startMotionPreview();
                }
            });
        }
        
        function startMotionPreview() {
            stopMotionPreview(); // Останавливаем предыдущую анимацию
            
            motionPreviewStartTime = Date.now();
            motionPreviewWatermark.style.width = '30px';
            motionPreviewWatermark.style.height = '30px';
            
            function animate() {
                const currentTime = Date.now();
                const elapsed = (currentTime - motionPreviewStartTime) / 1000; // в секундах
                
                const previewWidth = motionPreview.clientWidth;
                const previewHeight = motionPreview.clientHeight;
                
                // Обновляем позицию водяного знака
                const pos = calculateMotionPosition(
                    elapsed,
                    previewWidth,
                    previewHeight,
                    30, // ширина водяного знака
                    30, // высота водяного знака
                    parseInt(speedSlider.value) / 5,
                    motionType.value,
                    100, // амплитуда
                    0.5  // частота
                );
                
                // Обновляем позицию водяного знака
                motionPreviewWatermark.style.left = `${pos.x}px`;
                motionPreviewWatermark.style.top = `${pos.y}px`;
                
                // Продолжаем анимацию
                motionPreviewAnimation = requestAnimationFrame(animate);
            }
            
            motionPreviewAnimation = requestAnimationFrame(animate);
        }
        
        function calculateMotionPosition(time, width, height, wmWidth, wmHeight, speed, motionType, amplitude, frequency) {
            const maxX = width - wmWidth;
            const maxY = height - wmHeight;
            
            // Нормализованное время для периодических движений
            const t = time * speed;
            
            switch(motionType) {
                case 'bounce':
                    // Плавное движение с отскоками от краев
                    const bounceX = (Math.sin(t * frequency) * 0.5 + 0.5) * maxX;
                    const bounceY = (Math.cos(t * frequency * 0.7) * 0.5 + 0.5) * maxY;
                    return {
                        x: Math.max(0, Math.min(maxX, bounceX)),
                        y: Math.max(0, Math.min(maxY, bounceY))
                    };
                    
                case 'circular':
                    // Круговое движение по всей площади
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const radius = Math.min(maxX, maxY) * 0.4;
                    const angle = t * frequency;
                    
                    return {
                        x: centerX + Math.cos(angle) * radius - wmWidth / 2,
                        y: centerY + Math.sin(angle) * radius - wmHeight / 2
                    };
                    
                case 'horizontal':
                    // Горизонтальное движение туда-обратно
                    const hProgress = (Math.sin(t * frequency) * 0.5 + 0.5);
                    return {
                        x: hProgress * maxX,
                        y: height / 2 - wmHeight / 2
                    };
                    
                case 'vertical':
                    // Вертикальное движение туда-обратно
                    const vProgress = (Math.sin(t * frequency) * 0.5 + 0.5);
                    return {
                        x: width / 2 - wmWidth / 2,
                        y: vProgress * maxY
                    };
                    
                case 'diagonal':
                    // Диагональное движение
                    const diagProgress = (Math.sin(t * frequency) * 0.5 + 0.5);
                    return {
                        x: diagProgress * maxX,
                        y: diagProgress * maxY
                    };
                    
                case 'spiral':
                    // Спиральное движение от центра к краям
                    const spiralCenterX = width / 2;
                    const spiralCenterY = height / 2;
                    const spiralAngle = t * frequency;
                    const spiralRadius = (t % 10) / 10 * Math.min(maxX, maxY) * 0.5;
                    
                    return {
                        x: spiralCenterX + Math.cos(spiralAngle) * spiralRadius - wmWidth / 2,
                        y: spiralCenterY + Math.sin(spiralAngle) * spiralRadius - wmHeight / 2
                    };
                    
                case 'random':
                    // Псевдослучайное движение с плавными переходами
                    const randomX = (Math.sin(t * 0.3) * 0.5 + 0.5) * maxX;
                    const randomY = (Math.cos(t * 0.4) * 0.5 + 0.5) * maxY;
                    return {
                        x: Math.max(0, Math.min(maxX, randomX)),
                        y: Math.max(0, Math.min(maxY, randomY))
                    };
                    
                case 'wave':
                    // Волнообразное движение
                    const waveX = (t * 0.5) % maxX;
                    const waveY = Math.sin(t * frequency) * amplitude + height / 2 - wmHeight / 2;
                    
                    return {
                        x: waveX,
                        y: Math.max(0, Math.min(maxY, waveY))
                    };
                    
                case 'figure8':
                    // Движение по траектории восьмерки (лемниската Бернулли)
                    const scale = Math.min(width, height) * 0.3;
                    const figure8X = Math.sin(t * frequency) * scale + width / 2 - wmWidth / 2;
                    const figure8Y = Math.sin(t * frequency * 2) * scale * 0.5 + height / 2 - wmHeight / 2;
                    
                    return {
                        x: Math.max(0, Math.min(maxX, figure8X)),
                        y: Math.max(0, Math.min(maxY, figure8Y))
                    };
                    
                default:
                    return { x: 0, y: 0 };
            }
        }
        
        function stopMotionPreview() {
            if (motionPreviewAnimation) {
                cancelAnimationFrame(motionPreviewAnimation);
                motionPreviewAnimation = null;
            }
        }
        
        function updateColorValues() {
            textColorValue.textContent = textColor;
            strokeColorValue.textContent = strokeColor;
        }
        
        function highlightPreset(presetElement, container) {
            // Снимаем выделение со всех пресетов в контейнере
            container.querySelectorAll('.color-preset').forEach(p => {
                p.classList.remove('active');
            });
            
            // Выделяем выбранный пресет
            presetElement.classList.add('active');
        }
        
        function highlightPresetByColor(color, container) {
            const presets = container.querySelectorAll('.color-preset');
            let found = false;
            
            presets.forEach(preset => {
                if (preset.dataset.color === color) {
                    preset.classList.add('active');
                    found = true;
                } else {
                    preset.classList.remove('active');
                }
            });
            
            // Если цвет не найден среди пресетов, снимаем выделение со всех
            if (!found) {
                presets.forEach(preset => preset.classList.remove('active'));
            }
        }
        
        function loadSavedWatermarks() {
            const saved = localStorage.getItem('savedWatermarks');
            if (saved) {
                try {
                    savedWatermarks = JSON.parse(saved);
                    renderSavedWatermarksList();
                } catch (e) {
                    console.error('Ошибка загрузки сохраненных водяных знаков:', e);
                    savedWatermarks = [];
                }
            }
        }
        
        function renderSavedWatermarksList() {
            savedWatermarksList.innerHTML = '';
            
            if (savedWatermarks.length === 0) {
                savedWatermarksList.innerHTML = '<p style="color: #666; text-align: center; width: 100%;">Нет сохранённых водяных знаков</p>';
                return;
            }
            
            savedWatermarks.forEach((watermark, index) => {
                const item = document.createElement('div');
                item.className = 'saved-watermark-item';
                item.dataset.index = index;
                
                if (watermark.type === 'text') {
                    // Для текстовых водяных знаков показываем цвет
                    const colorBox = watermark.textColor ? 
                        `<div style="width: 100%; height: 20px; background-color: ${watermark.textColor}; border-radius: 3px; margin-bottom: 5px;"></div>` : 
                        '';
                    
                    const motionIcon = watermark.motionSettings ? '<i class="fas fa-running" style="color: #0072ff; margin-left: 5px;"></i>' : '';
                    
                    item.innerHTML = `
                        ${colorBox}
                        <div class="saved-watermark-text">${watermark.text} ${motionIcon}</div>
                        <div style="font-size: 10px; color: #666; margin-top: 5px;">${watermark.opacity}%</div>
                        <div class="saved-watermark-actions">
                            <button class="delete-watermark-btn" data-index="${index}">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                } else {
                    const motionIcon = watermark.motionSettings ? '<i class="fas fa-running" style="color: #0072ff; margin-left: 5px;"></i>' : '';
                    
                    item.innerHTML = `
                        <img src="${watermark.imageData}" class="saved-watermark-preview" alt="Watermark">
                        <div class="saved-watermark-text">Изображение ${motionIcon}</div>
                        <div style="font-size: 10px; color: #666; margin-top: 5px;">${watermark.opacity}%</div>
                        <div class="saved-watermark-actions">
                            <button class="delete-watermark-btn" data-index="${index}">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                }
                
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.delete-watermark-btn')) {
                        loadSavedWatermark(index);
                    }
                });
                
                const deleteBtn = item.querySelector('.delete-watermark-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSavedWatermark(index);
                });
                
                savedWatermarksList.appendChild(item);
            });
        }
        
        function loadSavedWatermark(index) {
            const watermark = savedWatermarks[index];
            if (!watermark) return;
            
            // Устанавливаем тип водяного знака
            setWatermarkType(watermark.type);
            
            // Устанавливаем настройки
            opacitySlider.value = watermark.opacity;
            opacityValue.textContent = `${watermark.opacity}%`;
            
            // Устанавливаем позицию
            positionButtons.forEach(btn => btn.classList.remove('active'));
            const positionBtn = document.querySelector(`.position-btn[data-position="${watermark.position}"]`);
            if (positionBtn) {
                positionBtn.classList.add('active');
                position = watermark.position;
            }
            
            // Загружаем данные водяного знака
            if (watermark.type === 'text') {
                watermarkText.value = watermark.text;
                
                // Устанавливаем цвета, если они есть
                if (watermark.textColor) {
                    textColor = watermark.textColor;
                    textColorPicker.value = textColor;
                }
                if (watermark.strokeColor) {
                    strokeColor = watermark.strokeColor;
                    strokeColorPicker.value = strokeColor;
                }
                updateColorValues();
                highlightPresetByColor(textColor, textColorPresets);
                highlightPresetByColor(strokeColor, strokeColorPresets);
            } else {
                watermarkImage = new Image();
                watermarkImage.src = watermark.imageData;
                watermarkImage.onload = function() {
                    watermarkImagePreview.src = watermark.imageData;
                    watermarkImagePreview.classList.remove('hidden');
                };
            }
            
            // Устанавливаем настройки движения, если они есть
            if (watermark.motionSettings) {
                movingWatermark.checked = true;
                motionSettings.classList.add('active');
                speedSlider.value = watermark.motionSettings.speed;
                speedValue.textContent = watermark.motionSettings.speed;
                motionType.value = watermark.motionSettings.motionType;
                
                // Запускаем предпросмотр движения
                startMotionPreview();
            } else {
                movingWatermark.checked = false;
                motionSettings.classList.remove('active');
                stopMotionPreview();
            }
            
            // Подсвечиваем выбранный элемент
            document.querySelectorAll('.saved-watermark-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`.saved-watermark-item[data-index="${index}"]`).classList.add('active');
            
            tg.HapticFeedback.impactOccurred('light');
        }
        
        function saveCurrentWatermark() {
            // Собираем данные текущего водяного знака
            const watermarkData = {
                type: watermarkType,
                opacity: opacitySlider.value,
                position: position,
                timestamp: Date.now()
            };
            
            if (watermarkType === 'text') {
                const text = watermarkText.value.trim();
                if (!text) {
                    alert('Введите текст водяного знака');
                    return;
                }
                watermarkData.text = text;
                watermarkData.textColor = textColor;
                watermarkData.strokeColor = strokeColor;
            } else {
                if (!watermarkImage) {
                    alert('Загрузите изображение водяного знака');
                    return;
                }
                watermarkData.imageData = watermarkImage.src;
            }
            
            // Сохраняем настройки движения, если они включены
            if (movingWatermark.checked) {
                watermarkData.motionSettings = {
                    moving: true,
                    speed: speedSlider.value,
                    motionType: motionType.value
                };
            }
            
            // Добавляем в массив сохраненных
            savedWatermarks.push(watermarkData);
            
            // Ограничиваем количество сохраненных водяных знаков (максимум 10)
            if (savedWatermarks.length > 10) {
                savedWatermarks = savedWatermarks.slice(-10);
            }
            
            // Сохраняем в localStorage
            localStorage.setItem('savedWatermarks', JSON.stringify(savedWatermarks));
            
            // Обновляем список
            renderSavedWatermarksList();
            
            tg.HapticFeedback.impactOccurred('medium');
            
            // Показываем уведомление
            showNotification('Водяной знак сохранен!');
        }
        
        function deleteSavedWatermark(index) {
            if (confirm('Удалить этот водяной знак?')) {
                savedWatermarks.splice(index, 1);
                localStorage.setItem('savedWatermarks', JSON.stringify(savedWatermarks));
                renderSavedWatermarksList();
                tg.HapticFeedback.impactOccurred('light');
            }
        }
        
        function showNotification(message) {
            // Создаем временное уведомление
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1001;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 2000);
            
            // Добавляем стили для анимации
            if (!document.querySelector('#notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        function goToStep(step) {
            // Обновляем индикатор шагов
            [step1, step2, step3].forEach(s => s.classList.remove('active', 'completed'));
            [step1Content, step2Content, step3Content].forEach(c => c.classList.remove('active'));
            
            // Отмечаем предыдущие шаги как выполненные
            for (let i = 1; i < step; i++) {
                document.getElementById(`step${i}`).classList.add('completed');
            }
            
            // Активируем текущий шаг
            document.getElementById(`step${step}`).classList.add('active');
            document.getElementById(`step${step}Content`).classList.add('active');
            
            currentStep = step;
            
            tg.HapticFeedback.impactOccurred('light');
        }
        
        function setWatermarkType(type) {
            watermarkType = type;
            
            if (type === 'text') {
                textTypeOption.classList.add('active');
                imageTypeOption.classList.remove('active');
                textWatermarkControl.classList.remove('hidden');
                imageWatermarkControl.classList.add('hidden');
            } else {
                textTypeOption.classList.remove('active');
                imageTypeOption.classList.add('active');
                textWatermarkControl.classList.add('hidden');
                imageWatermarkControl.classList.remove('hidden');
            }
        }
        
        function handleMediaUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const fileType = file.type;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                originalMedia = {
                    file: file,
                    url: e.target.result,
                    type: fileType
                };
                
                originalFormat = fileType;
                originalFileName = file.name;
                
                // Определяем, является ли файл видео
                isVideo = fileType.startsWith('video/');
                
                // Показываем предпросмотр
                if (isVideo) {
                    mediaPreview.classList.add('hidden');
                    videoContainer.classList.remove('hidden');
                    noPreview.classList.add('hidden');
                    
                    videoPreview.src = e.target.result;
                    videoPreview.load();
                    
                    videoPreview.onloadedmetadata = function() {
                        videoDuration = videoPreview.duration;
                        updateMediaInfo(file, videoDuration);
                        
                        // Настраиваем размер контейнера в зависимости от пропорций видео
                        const aspectRatio = videoPreview.videoWidth / videoPreview.videoHeight;
                        const maxWidth = 500;
                        const maxHeight = 400;
                        
                        if (aspectRatio > 1) {
                            // Горизонтальное видео
                            videoContainer.style.width = '100%';
                            videoContainer.style.maxWidth = `${maxWidth}px`;
                        } else {
                            // Вертикальное видео
                            videoContainer.style.width = 'auto';
                            videoContainer.style.maxWidth = '300px';
                        }
                    };
                } else {
                    videoContainer.classList.add('hidden');
                    mediaPreview.classList.remove('hidden');
                    noPreview.classList.add('hidden');
                    
                    mediaPreview.src = e.target.result;
                    
                    // Настраиваем размер изображения
                    const img = new Image();
                    img.onload = function() {
                        const aspectRatio = img.width / img.height;
                        if (aspectRatio > 1.5) {
                            mediaPreview.style.maxWidth = '100%';
                            mediaPreview.style.maxHeight = '400px';
                        } else {
                            mediaPreview.style.maxWidth = 'auto';
                            mediaPreview.style.maxHeight = '400px';
                        }
                    };
                    img.src = e.target.result;
                    
                    updateMediaInfo(file);
                }
                
                changeMediaBtn.classList.remove('hidden');
                applyWatermarkBtn.disabled = false;
                
                tg.HapticFeedback.impactOccurred('light');
            };
            
            reader.readAsDataURL(file);
        }
        
        function updateMediaInfo(file, duration = null) {
            const sizeInMB = (file.size / (1024 * 1024)).toFixed(2);
            let info = `Формат: ${originalFormat.split('/')[1].toUpperCase()} | Размер: ${sizeInMB} МБ`;
            
            if (duration) {
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                info += ` | Длительность: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            mediaInfo.textContent = info;
            mediaInfo.classList.remove('hidden');
        }
        
        function handleWatermarkImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                watermarkImage = new Image();
                watermarkImage.src = e.target.result;
                
                watermarkImagePreview.src = e.target.result;
                watermarkImagePreview.classList.remove('hidden');
            };
            
            reader.readAsDataURL(file);
        }
        
        function showProcessing(text) {
            processingText.textContent = text;
            processingOverlay.style.display = 'flex';
        }
        
        function hideProcessing() {
            processingOverlay.style.display = 'none';
        }
        
        function updateVideoProcessingProgress(current, total, startTime) {
            const percentage = Math.round((current / total) * 100);
            videoProcessingPercentage.textContent = `${percentage}%`;
            videoProcessingProgressBar.style.width = `${percentage}%`;
            processedFrames.textContent = current;
            totalFrames.textContent = total;
            
            // Рассчитываем скорость обработки
            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000; // в секундах
            const fps = current > 0 ? (current / elapsedTime).toFixed(1) : 0;
            processingSpeed.textContent = `${fps} кадр/сек`;
            
            // Рассчитываем оставшееся время
            if (current > 0 && elapsedTime > 0) {
                const framesPerSecond = current / elapsedTime;
                const remainingFrames = total - current;
                const remainingTime = framesPerSecond > 0 ? remainingFrames / framesPerSecond : 0;
                
                if (remainingTime < 60) {
                    videoProcessingTime.textContent = `Осталось: ${Math.round(remainingTime)} сек`;
                } else if (remainingTime < 3600) {
                    videoProcessingTime.textContent = `Осталось: ${Math.round(remainingTime / 60)} мин`;
                } else {
                    videoProcessingTime.textContent = `Осталось: ${Math.round(remainingTime / 3600)} час`;
                }
            }
        }
        
        function cancelVideoProcessing() {
            videoProcessingActive = false;
            videoProcessingContainer.classList.remove('active');
            
            if (currentMediaRecorder && currentMediaRecorder.state === 'recording') {
                currentMediaRecorder.stop();
            }
            
            showNotification('Обработка отменена');
            applyWatermarkBtn.disabled = false;
        }
        
        async function applyWatermark() {
            if (!originalMedia) return;
            
            applyWatermarkBtn.disabled = true;
            
            try {
                if (isVideo) {
                    // Показываем контейнер прогресса обработки видео
                    videoProcessingContainer.classList.add('active');
                    videoProcessingActive = true;
                    videoProcessingStartTime = Date.now();
                    
                    await processVideo();
                    
                    // Скрываем контейнер прогресса после завершения
                    videoProcessingContainer.classList.remove('active');
                } else {
                    showProcessing('Наложение водяного знака...');
                    await processImage();
                    hideProcessing();
                }
                
                // Переходим к шагу 3
                goToStep(3);
                downloadResultBtn.disabled = false;
                
                tg.HapticFeedback.impactOccurred('medium');
            } catch (error) {
                console.error('Ошибка обработки:', error);
                alert('Произошла ошибка при обработке. Попробуйте снова.');
                
                // Скрываем контейнер прогресса в случае ошибки
                videoProcessingContainer.classList.remove('active');
            } finally {
                applyWatermarkBtn.disabled = false;
            }
        }
        
        function processImage() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    // Применяем водяной знак
                    applyWatermarkToCanvas(ctx, canvas.width, canvas.height);
                    
                    let mimeType = originalFormat;
                    if (!mimeType || mimeType === 'image/gif') {
                        mimeType = 'image/png';
                    }
                    
                    try {
                        processedMedia = canvas.toDataURL(mimeType);
                    } catch (e) {
                        processedMedia = canvas.toDataURL('image/png');
                    }
                    
                    // Показываем результат
                    processedMediaPreview.src = processedMedia;
                    processedMediaPreview.classList.remove('hidden');
                    processedVideoContainer.classList.add('hidden');
                    noProcessedPreview.classList.add('hidden');
                    
                    // Настраиваем размер изображения
                    const aspectRatio = img.width / img.height;
                    if (aspectRatio > 1.5) {
                        processedMediaPreview.style.maxWidth = '100%';
                        processedMediaPreview.style.maxHeight = '400px';
                    } else {
                        processedMediaPreview.style.maxWidth = 'auto';
                        processedMediaPreview.style.maxHeight = '400px';
                    }
                    
                    resolve();
                };
                
                img.src = originalMedia.url;
            });
        }
        
        function processVideo() {
            return new Promise((resolve) => {
                const tempVideo = document.createElement('video');
                tempVideo.src = originalMedia.url;
                tempVideo.muted = true;
                tempVideo.crossOrigin = 'anonymous';
                
                tempVideo.onloadeddata = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = tempVideo.videoWidth;
                    canvas.height = tempVideo.videoHeight;
                    
                    // Инициализируем состояние водяного знака
                    initializeWatermarkState(canvas.width, canvas.height);
                    
                    let fps = 30;
                    const totalFramesCount = Math.floor(videoDuration * fps);
                    totalVideoFrames = totalFramesCount;
                    framesProcessed = 0;
                    
                    videoFrames = [];
                    
                    function processFrame() {
                        if (!videoProcessingActive) {
                            rejectVideoProcessing();
                            return;
                        }
                        
                        tempVideo.currentTime = framesProcessed / fps;
                        
                        tempVideo.onseeked = function() {
                            if (!videoProcessingActive) {
                                rejectVideoProcessing();
                                return;
                            }
                            
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
                            
                            // Применяем водяной знак
                            applyWatermarkToCanvasWithMotion(
                                ctx, 
                                canvas.width, 
                                canvas.height, 
                                framesProcessed / totalFramesCount // прогресс от 0 до 1
                            );
                            
                            videoFrames.push(canvas.toDataURL('image/jpeg', 1.0));
                            framesProcessed++;
                            
                            // Обновляем прогресс
                            updateVideoProcessingProgress(framesProcessed, totalFramesCount, videoProcessingStartTime);
                            
                            if (framesProcessed < totalFramesCount) {
                                setTimeout(processFrame, 0);
                            } else {
                                createVideoFromFrames(fps).then(resolve).catch(() => {
                                    videoProcessingContainer.classList.remove('active');
                                });
                            }
                        };
                    }
                    
                    processFrame();
                };
                
                tempVideo.load();
                
                function rejectVideoProcessing() {
                    videoProcessingContainer.classList.remove('active');
                    applyWatermarkBtn.disabled = false;
                    throw new Error('Обработка отменена');
                }
            });
        }
        
        function initializeWatermarkState(videoWidth, videoHeight) {
            // Вычисляем размер водяного знака
            let watermarkWidth, watermarkHeight;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                // Для текста создаем временный canvas для измерения
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const fontSize = Math.min(videoWidth, videoHeight) * 0.05;
                
                tempCtx.font = `bold ${fontSize}px Arial`;
                const text = watermarkText.value.trim();
                const textMetrics = tempCtx.measureText(text);
                
                watermarkWidth = textMetrics.width + fontSize;
                watermarkHeight = fontSize * 2;
                
                // Сохраняем размер шрифта для использования в отрисовке
                watermarkState.fontSize = fontSize;
            } else if (watermarkType === 'image' && watermarkImage) {
                watermarkWidth = videoWidth * 0.2;
                watermarkHeight = (watermarkImage.height / watermarkImage.width) * watermarkWidth;
            } else {
                // Значения по умолчанию
                watermarkWidth = videoWidth * 0.2;
                watermarkHeight = videoHeight * 0.1;
            }
            
            // Устанавливаем начальное состояние водяного знака
            watermarkState.width = watermarkWidth;
            watermarkState.height = watermarkHeight;
            watermarkState.videoWidth = videoWidth;
            watermarkState.videoHeight = videoHeight;
            watermarkState.speed = parseInt(speedSlider.value) / 5;
            watermarkState.motionType = motionType.value;
            watermarkState.amplitude = 100;
            watermarkState.frequency = 0.5;
        }
        
        function applyWatermarkToCanvas(ctx, width, height) {
            const opacity = parseInt(opacitySlider.value) / 100;
            
            // Для статичного водяного знака вычисляем позицию
            let x, y, watermarkWidth, watermarkHeight;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const fontSize = Math.min(width, height) * 0.05;
                ctx.font = `bold ${fontSize}px Arial`;
                const text = watermarkText.value.trim();
                const textMetrics = ctx.measureText(text);
                
                watermarkWidth = textMetrics.width + fontSize;
                watermarkHeight = fontSize * 2;
                
                switch(position) {
                    case 'top-left':
                        x = 10;
                        y = 10;
                        break;
                    case 'top-center':
                        x = (width - watermarkWidth) / 2;
                        y = 10;
                        break;
                    case 'top-right':
                        x = width - watermarkWidth - 10;
                        y = 10;
                        break;
                    case 'center-left':
                        x = 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center':
                        x = (width - watermarkWidth) / 2;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center-right':
                        x = width - watermarkWidth - 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = 10;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-center':
                        x = (width - watermarkWidth) / 2;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-right':
                        x = width - watermarkWidth - 10;
                        y = height - watermarkHeight - 10;
                        break;
                }
            } else if (watermarkType === 'image' && watermarkImage) {
                watermarkWidth = width * 0.2;
                watermarkHeight = (watermarkImage.height / watermarkImage.width) * watermarkWidth;
                
                switch(position) {
                    case 'top-left':
                        x = 10;
                        y = 10;
                        break;
                    case 'top-center':
                        x = (width - watermarkWidth) / 2;
                        y = 10;
                        break;
                    case 'top-right':
                        x = width - watermarkWidth - 10;
                        y = 10;
                        break;
                    case 'center-left':
                        x = 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center':
                        x = (width - watermarkWidth) / 2;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center-right':
                        x = width - watermarkWidth - 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = 10;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-center':
                        x = (width - watermarkWidth) / 2;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-right':
                        x = width - watermarkWidth - 10;
                        y = height - watermarkHeight - 10;
                        break;
                }
            }
            
            // Устанавливаем прозрачность
            ctx.globalAlpha = opacity;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const text = watermarkText.value.trim();
                const fontSize = Math.min(width, height) * 0.05;
                ctx.font = `bold ${fontSize}px Arial`;
                
                // Рисуем текст с обводкой и заливкой
                ctx.strokeStyle = strokeColor;
                ctx.fillStyle = textColor;
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Вычисляем центр для текста
                const centerX = x + (watermarkWidth / 2);
                const centerY = y + (watermarkHeight / 2);
                
                ctx.strokeText(text, centerX, centerY);
                ctx.fillText(text, centerX, centerY);
                
            } else if (watermarkType === 'image' && watermarkImage) {
                // Водяная марка из изображения
                ctx.drawImage(watermarkImage, x, y, watermarkWidth, watermarkHeight);
            }
            
            // Сбрасываем прозрачность
            ctx.globalAlpha = 1.0;
        }
        
        function applyWatermarkToCanvasWithMotion(ctx, width, height, progress) {
            const opacity = parseInt(opacitySlider.value) / 100;
            
            // Если движение не включено, используем статичную позицию
            if (!movingWatermark.checked) {
                applyWatermarkToCanvas(ctx, width, height);
                return;
            }
            
            // Вычисляем позицию на основе прогресса видео
            const time = progress * 60; // Преобразуем прогресс в "виртуальное время"
            const pos = calculateMotionPosition(
                time,
                width,
                height,
                watermarkState.width,
                watermarkState.height,
                watermarkState.speed,
                watermarkState.motionType,
                watermarkState.amplitude,
                watermarkState.frequency
            );
            
            let x = Math.max(0, Math.min(width - watermarkState.width, pos.x));
            let y = Math.max(0, Math.min(height - watermarkState.height, pos.y));
            
            // Устанавливаем прозрачность
            ctx.globalAlpha = opacity;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const text = watermarkText.value.trim();
                
                if (watermarkState.fontSize) {
                    ctx.font = `bold ${watermarkState.fontSize}px Arial`;
                } else {
                    const fontSize = Math.min(width, height) * 0.05;
                    ctx.font = `bold ${fontSize}px Arial`;
                }
                
                // Рисуем текст с обводкой и заливкой
                ctx.strokeStyle = strokeColor;
                ctx.fillStyle = textColor;
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Вычисляем центр для текста
                const centerX = x + (watermarkState.width / 2);
                const centerY = y + (watermarkState.height / 2);
                
                ctx.strokeText(text, centerX, centerY);
                ctx.fillText(text, centerX, centerY);
                
            } else if (watermarkType === 'image' && watermarkImage) {
                // Водяная марка из изображения
                ctx.drawImage(watermarkImage, x, y, watermarkState.width, watermarkState.height);
            }
            
            // Сбрасываем прозрачность
            ctx.globalAlpha = 1.0;
        }
        
        function createVideoFromFrames(fps) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = videoPreview.videoWidth;
                canvas.height = videoPreview.videoHeight;
                
                const stream = canvas.captureStream(fps);
                
                let mimeType = 'video/webm;codecs=vp9';
                if (originalFormat.includes('mp4') && MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.42E01E')) {
                    mimeType = 'video/mp4;codecs=avc1.42E01E';
                }
                
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000
                });
                
                currentMediaRecorder = mediaRecorder;
                
                const chunks = [];
                
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = function() {
                    const blob = new Blob(chunks, { 
                        type: mimeType.split(';')[0]
                    });
                    const url = URL.createObjectURL(blob);
                    processedMedia = {
                        url: url,
                        type: mimeType.split(';')[0],
                        blob: blob
                    };
                    
                    processedVideoPreview.src = url;
                    processedVideoContainer.classList.remove('hidden');
                    processedMediaPreview.classList.add('hidden');
                    noProcessedPreview.classList.add('hidden');
                    
                    // Настраиваем размер контейнера для обработанного видео
                    const aspectRatio = videoPreview.videoWidth / videoPreview.videoHeight;
                    const maxWidth = 500;
                    
                    if (aspectRatio > 1) {
                        // Горизонтальное видео
                        processedVideoContainer.style.width = '100%';
                        processedVideoContainer.style.maxWidth = `${maxWidth}px`;
                    } else {
                        // Вертикальное видео
                        processedVideoContainer.style.width = 'auto';
                        processedVideoContainer.style.maxWidth = '300px';
                    }
                    
                    currentMediaRecorder = null;
                    resolve();
                };
                
                mediaRecorder.start();
                
                let frameIndex = 0;
                const totalFrames = videoFrames.length;
                
                function drawNextFrame() {
                    if (!videoProcessingActive || frameIndex >= totalFrames) {
                        mediaRecorder.stop();
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = function() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        frameIndex++;
                        setTimeout(drawNextFrame, 1000 / fps);
                    };
                    
                    img.src = videoFrames[frameIndex];
                }
                
                drawNextFrame();
            });
        }
        
        function handleDownload() {
            if (!processedMedia) return;
            
            // Для мобильных устройств используем API для сохранения
            if (isMobileDevice()) {
                showMobileSaveOptions();
            } else {
                // Для десктопов используем стандартное скачивание
                downloadFile();
            }
        }
        
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        function showMobileSaveOptions() {
            // Показываем опции сохранения
            saveOptions.classList.remove('hidden');
        }
        
        function downloadFile() {
            if (!processedMedia) return;
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const originalName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
            
            if (isVideo) {
                link.href = processedMedia.url;
                let extension = 'webm';
                if (processedMedia.type === 'video/mp4') {
                    extension = 'mp4';
                }
                link.download = `TgPosted_${originalName}_${timestamp}.${extension}`;
            } else {
                link.href = processedMedia;
                let extension = 'png';
                if (originalFormat.includes('jpeg') || originalFormat.includes('jpg')) {
                    extension = 'jpg';
                } else if (originalFormat.includes('png')) {
                    extension = 'png';
                } else if (originalFormat.includes('gif')) {
                    extension = 'gif';
                }
                link.download = `TgPosted_${originalName}_${timestamp}.${extension}`;
            }
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Показываем информацию о сохранении
            showSavePathInfo(`Файл сохранен как: ${link.download} (в папке загрузок)`);
            
            tg.HapticFeedback.impactOccurred('medium');
        }
        
        async function saveToGallery() {
            if (!processedMedia) return;
            
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const originalName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
                
                // Определяем тип файла и расширение
                let extension, mimeType, fileName;
                
                if (isVideo) {
                    extension = processedMedia.type === 'video/mp4' ? 'mp4' : 'webm';
                    mimeType = processedMedia.type;
                    fileName = `TgPosted_${originalName}_${timestamp}.${extension}`;
                } else {
                    // Определяем расширение для изображения
                    if (originalFormat.includes('jpeg') || originalFormat.includes('jpg')) {
                        extension = 'jpg';
                        mimeType = 'image/jpeg';
                    } else if (originalFormat.includes('png')) {
                        extension = 'png';
                        mimeType = 'image/png';
                    } else if (originalFormat.includes('gif')) {
                        extension = 'gif';
                        mimeType = 'image/gif';
                    } else {
                        extension = 'png';
                        mimeType = 'image/png';
                    }
                    fileName = `TgPosted_${originalName}_${timestamp}.${extension}`;
                }
                
                // Создаем Blob из обработанного медиа
                let blob;
                if (isVideo) {
                    blob = processedMedia.blob;
                } else {
                    // Для изображения извлекаем данные из DataURL
                    const response = await fetch(processedMedia);
                    blob = await response.blob();
                }
                
                // Пробуем сохранить через File System Access API
                if ('showSaveFilePicker' in window) {
                    try {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: fileName,
                            types: [{
                                description: isVideo ? 'Video File' : 'Image File',
                                accept: {
                                    [mimeType]: [`.${extension}`]
                                }
                            }],
                        });
                        
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        // Показываем информацию о сохранении
                        showSavePathInfo(`Файл сохранен: ${fileName}\nПуть: ${fileHandle.name || 'В выбранную папку'}`);
                        
                        tg.HapticFeedback.impactOccurred('medium');
                        return;
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.log('File System Access API не сработал, пробуем другой метод:', err);
                        }
                    }
                }
                
                // Пробуем через Share API (работает на многих мобильных устройствах)
                if (navigator.share && navigator.canShare) {
                    try {
                        const file = new File([blob], fileName, { type: mimeType });
                        
                        if (navigator.canShare({ files: [file] })) {
                            await navigator.share({
                                files: [file],
                                title: 'Обработанный файл с водяным знаком',
                                text: 'Сохраните этот файл в галерею'
                            });
                            
                            // Показываем информацию о сохранении
                            showSavePathInfo(`Файл отправлен для сохранения: ${fileName}\nСохраните его в галерею через диалог шаринга`);
                            
                            tg.HapticFeedback.impactOccurred('medium');
                            return;
                        }
                    } catch (err) {
                        console.log('Share API не сработал:', err);
                    }
                }
                
                // Для Android Chrome - используем скачивание
                if (navigator.userAgent.toLowerCase().includes('android')) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Показываем информацию о сохранении
                    showSavePathInfo(`Файл сохранен как: ${fileName}\nНайдите его в папке "Загрузки" и переместите в галерею`);
                    
                    tg.HapticFeedback.impactOccurred('medium');
                    return;
                }
                
                // Для iOS - пробуем скачать через новую вкладку
                if (navigator.userAgent.toLowerCase().includes('iphone') || 
                    navigator.userAgent.toLowerCase().includes('ipad')) {
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;
                    link.target = '_blank';
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Показываем инструкцию для iOS
                    showSavePathInfo(`Файл сохранен как: ${fileName}\nДля iOS: Нажмите "Поделиться" → "Сохранить в Фото"`);
                    
                    tg.HapticFeedback.impactOccurred('medium');
                    return;
                }
                
                // Фолбэк - обычное скачивание
                downloadFile();
                
            } catch (error) {
                console.error('Ошибка сохранения в галерею:', error);
                showNotification('Не удалось сохранить в галерею. Используйте "Скачать результат".');
                
                // Пробуем скачать обычным способом
                downloadFile();
            }
        }
        
        function showSavePathInfo(message) {
            savePathText.textContent = message;
            savePathInfo.classList.add('active');
            
            // Автоматически скрываем через 10 секунд
            setTimeout(() => {
                savePathInfo.classList.remove('active');
            }, 10000);
        }
        
        function copyPathToClipboard() {
            const text = savePathText.textContent;
            
            // Пробуем использовать современный Clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showNotification('Путь скопирован в буфер обмена!');
                    })
                    .catch(err => {
                        console.error('Ошибка копирования в буфер:', err);
                        fallbackCopyText(text);
                    });
            } else {
                fallbackCopyText(text);
            }
        }
        
        function fallbackCopyText(text) {
            // Старый способ для браузеров без поддержки Clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showNotification('Путь скопирован в буфер обмена!');
                } else {
                    showNotification('Не удалось скопировать путь');
                }
            } catch (err) {
                console.error('Ошибка копирования:', err);
                showNotification('Не удалось скопировать путь');
            }
            
            document.body.removeChild(textArea);
        }
        
        function shareFile() {
            if (!processedMedia) return;
            
            // Используем Web Share API если доступен
            if (navigator.share) {
                shareWithWebAPI();
            } else {
                // Fallback: копируем ссылку
                copyToClipboard();
            }
        }
        
        async function shareWithWebAPI() {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const originalName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
                
                // Создаем Blob для шаринга
                let blob, fileName, mimeType;
                
                if (isVideo) {
                    blob = processedMedia.blob;
                    mimeType = processedMedia.type;
                    let extension = processedMedia.type === 'video/mp4' ? 'mp4' : 'webm';
                    fileName = `TgPosted_${originalName}_${timestamp}.${extension}`;
                } else {
                    const response = await fetch(processedMedia);
                    blob = await response.blob();
                    mimeType = blob.type;
                    
                    let extension = 'png';
                    if (originalFormat.includes('jpeg') || originalFormat.includes('jpg')) {
                        extension = 'jpg';
                    } else if (originalFormat.includes('png')) {
                        extension = 'png';
                    } else if (originalFormat.includes('gif')) {
                        extension = 'gif';
                    }
                    fileName = `TgPosted_${originalName}_${timestamp}.${extension}`;
                }
                
                // Создаем файл для шаринга
                const file = new File([blob], fileName, { type: mimeType });
                
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'Обработанный файл с водяным знаком',
                        text: 'Посмотрите мой обработанный файл с водяным знаком!'
                    });
                    
                    tg.HapticFeedback.impactOccurred('medium');
                } else {
                    // Если нельзя шарить файлы, шарим текст
                    await navigator.share({
                        title: 'Обработанный файл с водяным знаком',
                        text: 'Я обработал файл с водяным знаком!'
                    });
                }
                
            } catch (err) {
                console.error('Ошибка шаринга:', err);
                copyToClipboard();
            }
        }
        
        function copyToClipboard() {
            // Создаем временную ссылку для копирования
            const tempInput = document.createElement('input');
            tempInput.value = processedMedia.url || processedMedia;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            showNotification('Ссылка скопирована в буфер обмена!');
            tg.HapticFeedback.impactOccurred('light');
        }
        
        function resetAll() {
            // Сбрасываем все шаги
            currentStep = 1;
            goToStep(1);
            
            // Сброс состояния
            originalMedia = null;
            processedMedia = null;
            watermarkImage = null;
            videoFrames = [];
            videoProcessingActive = false;
            
            // Сброс UI
            mediaPreview.classList.add('hidden');
            videoContainer.classList.add('hidden');
            noPreview.classList.remove('hidden');
            changeMediaBtn.classList.add('hidden');
            mediaInfo.classList.add('hidden');
            
            processedMediaPreview.classList.add('hidden');
            processedVideoContainer.classList.add('hidden');
            noProcessedPreview.classList.remove('hidden');
            
            watermarkImagePreview.classList.add('hidden');
            watermarkImageInput.value = '';
            fileInput.value = '';
            
            // Скрываем контейнер прогресса обработки видео
            videoProcessingContainer.classList.remove('active');
            
            // Скрываем информацию о сохранении
            savePathInfo.classList.remove('active');
            
            applyWatermarkBtn.disabled = true;
            downloadResultBtn.disabled = true;
            saveOptions.classList.add('hidden');
            
            // Сброс настроек
            watermarkText.value = '@TgPosted';
            opacitySlider.value = 70;
            opacityValue.textContent = '70%';
            
            // Сброс настроек движения
            movingWatermark.checked = false;
            motionSettings.classList.remove('active');
            speedSlider.value = 5;
            speedValue.textContent = '5';
            motionType.value = 'bounce';
            stopMotionPreview();
            
            // Сброс выбора пресетов движения
            document.querySelectorAll('.motion-preset').forEach(p => {
                p.classList.remove('active');
            });
            
            positionButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('.position-btn[data-position="bottom-right"]').classList.add('active');
            position = 'bottom-right';
            
            // Сброс цветов
            textColor = '#FFFFFF';
            strokeColor = '#000000';
            textColorPicker.value = textColor;
            strokeColorPicker.value = strokeColor;
            updateColorValues();
            highlightPresetByColor(textColor, textColorPresets);
            highlightPresetByColor(strokeColor, strokeColorPresets);
            
            setWatermarkType('text');
            
            // Снимаем выделение с сохраненных водяных знаков
            document.querySelectorAll('.saved-watermark-item').forEach(item => {
                item.classList.remove('active');
            });
            
            tg.HapticFeedback.impactOccurred('light');
        }
    </script>
</body>
</html>
