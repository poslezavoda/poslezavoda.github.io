<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TgPosted - Водяные знаки для Telegram</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Все предыдущие стили остаются без изменений */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        /* ... (все остальные стили остаются без изменений) ... */

        /* Новые стили для кнопки отправки */
        .btn-purple {
            background: linear-gradient(90deg, #8B00FF, #6A0DAD);
            color: white;
        }

        .btn-purple:hover {
            box-shadow: 0 6px 20px rgba(139, 0, 255, 0.2);
        }

        .btn-orange {
            background: linear-gradient(90deg, #FF6B00, #FF8C00);
            color: white;
        }

        .btn-orange:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 0, 0.2);
        }

        .send-bot-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
            gap: 15px;
        }

        .send-bot-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .telegram-info {
            background: #0088cc;
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            max-width: 300px;
            margin: 10px auto;
        }

        /* Стили для сообщения об отправке */
        .sent-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 1001;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: slideIn 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sent-message.error {
            background: #FF4444;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Для мобильных устройств */
        @media (max-width: 600px) {
            .send-bot-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
            
            .sent-message {
                top: 10px;
                right: 10px;
                left: 10px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-paperclip"></i> TgPosted</h1>
            <p>Наложение водяных знаков на фото и видео для Telegram</p>
        </div>

        <!-- Индикатор шагов -->
        <div class="steps-indicator">
            <div class="step active" id="step1">
                <div class="step-circle">1</div>
                <div class="step-text">Создание вотермарки</div>
            </div>
            <div class="step" id="step2">
                <div class="step-circle">2</div>
                <div class="step-text">Загрузка медиа</div>
            </div>
            <div class="step" id="step3">
                <div class="step-circle">3</div>
                <div class="step-text">Результат</div>
            </div>
        </div>

        <!-- Шаг 1: Создание вотермарки -->
        <div class="card step-content active" id="step1Content">
            <!-- ... (код шага 1 без изменений) ... -->
        </div>

        <!-- Шаг 2: Загрузка медиа -->
        <div class="card step-content" id="step2Content">
            <!-- ... (код шага 2 без изменений) ... -->
        </div>

        <!-- Шаг 3: Результат -->
        <div class="card step-content" id="step3Content">
            <h2 class="card-title"><i class="fas fa-check-circle"></i> Результат</h2>
            
            <div class="preview-container">
                <div class="preview-title">Обработанное медиа:</div>
                
                <!-- Контейнер для обработанного видео -->
                <div class="video-container hidden" id="processedVideoContainer">
                    <video id="processedVideoPreview" controls></video>
                </div>
                
                <!-- Обработанное изображение -->
                <img id="processedMediaPreview" class="hidden">
                
                <div id="noProcessedPreview" class="preview-title" style="text-align: center; width: 100%; padding: 40px 0; color: #999;">
                    <i class="fas fa-water" style="font-size: 48px; margin-bottom: 15px; display: block;"></i>
                    Водяной знак ещё не наложен
                </div>
            </div>

            <!-- Кнопки для скачивания и отправки -->
            <div class="send-bot-container">
                <div class="send-bot-buttons">
                    <button class="btn btn-success" id="downloadResultBtn" disabled>
                        <i class="fas fa-download"></i> Скачать результат
                    </button>
                    <button class="btn btn-purple" id="sendToBotBtn" disabled>
                        <i class="fab fa-telegram"></i> Отправить в Telegram
                    </button>
                </div>
                
                <div class="telegram-info" id="telegramInfo">
                    <i class="fab fa-telegram"></i>
                    <span>Файл будет отправлен в ваш чат с ботом</span>
                </div>
                
                <!-- Кнопка для отправки в группу/канал -->
                <button class="btn btn-orange" id="sendToChatBtn" disabled>
                    <i class="fas fa-users"></i> Отправить в группу/канал
                </button>
            </div>

            <div class="navigation-buttons">
                <button class="btn btn-secondary" id="backToStep2">
                    <i class="fas fa-arrow-left"></i> Назад к загрузке
                </button>
                <button class="btn btn-primary" id="processNewBtn">
                    <i class="fas fa-plus"></i> Обработать новый файл
                </button>
            </div>
        </div>

        <div class="footer">
            <p>Вся обработка происходит на вашем устройстве. Качество и FPS видео сохраняются.</p>
            <p style="margin-top: 10px;">Для работы с Telegram: добавьте этот код в мини-приложение через BotFather</p>
        </div>
    </div>

    <div class="processing-overlay" id="processingOverlay">
        <div class="spinner"></div>
        <div class="processing-text" id="processingText">Обработка...</div>
    </div>

    <!-- Модальное окно для выбора чата -->
    <div class="processing-overlay" id="chatSelectionOverlay" style="display: none;">
        <div class="card" style="max-width: 400px; width: 90%;">
            <h2 class="card-title"><i class="fas fa-users"></i> Выберите чат</h2>
            <p style="margin-bottom: 20px; color: #666;">Выберите куда отправить обработанный файл:</p>
            
            <div class="controls" style="margin-bottom: 20px;">
                <div class="control-group">
                    <label>Тип чата:</label>
                    <select id="chatType" style="width: 100%;">
                        <option value="private">Личный чат с ботом</option>
                        <option value="group">Группа</option>
                        <option value="channel">Канал</option>
                    </select>
                </div>
                
                <div class="control-group" id="chatIdGroup" style="display: none;">
                    <label for="chatIdInput">ID чата/канала:</label>
                    <input type="text" id="chatIdInput" placeholder="@username или -1001234567890">
                    <small style="color: #666; font-size: 12px;">Для каналов используйте ID формата -1001234567890</small>
                </div>
            </div>
            
            <div class="navigation-buttons">
                <button class="btn btn-secondary" id="cancelChatSelectBtn">
                    Отмена
                </button>
                <button class="btn btn-primary" id="confirmSendBtn">
                    Отправить
                </button>
            </div>
        </div>
    </div>

    <script>
        // Инициализация Telegram Web App
        let tg = window.Telegram.WebApp;
        tg.expand();
        tg.enableClosingConfirmation();
        
        // === НОВЫЕ ПЕРЕМЕННЫЕ ===
        // Конфигурация бота (замените на свои данные)
        const BOT_TOKEN = 'YOUR_BOT_TOKEN'; // Замените на токен вашего бота
        const API_URL = `https://api.telegram.org/bot${BOT_TOKEN}`;
        
        // === ВСЕ ПРЕДЫДУЩИЕ ПЕРЕМЕННЫЕ ===
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const step1Content = document.getElementById('step1Content');
        const step2Content = document.getElementById('step2Content');
        const step3Content = document.getElementById('step3Content');
        
        // Элементы для навигации
        const nextToStep2Btn = document.getElementById('nextToStep2');
        const backToStep1Btn = document.getElementById('backToStep1');
        const backToStep2Btn = document.getElementById('backToStep2');
        const applyWatermarkBtn = document.getElementById('applyWatermarkBtn');
        const processNewBtn = document.getElementById('processNewBtn');
        const resetAllBtn = document.getElementById('resetAllBtn');
        
        // Элементы для водяного знака
        const watermarkText = document.getElementById('watermarkText');
        const watermarkImageInput = document.getElementById('watermarkImageInput');
        const watermarkUploadArea = document.getElementById('watermarkUploadArea');
        const watermarkImagePreview = document.getElementById('watermarkImagePreview');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');
        const positionButtons = document.querySelectorAll('.position-btn');
        const textTypeOption = document.getElementById('textTypeOption');
        const imageTypeOption = document.getElementById('imageTypeOption');
        const textWatermarkControl = document.getElementById('textWatermarkControl');
        const imageWatermarkControl = document.getElementById('imageWatermarkControl');
        
        // Элементы для цвета текста
        const textColorPicker = document.getElementById('textColorPicker');
        const textColorValue = document.getElementById('textColorValue');
        const textColorPresets = document.getElementById('textColorPresets');
        const strokeColorPicker = document.getElementById('strokeColorPicker');
        const strokeColorValue = document.getElementById('strokeColorValue');
        const strokeColorPresets = document.getElementById('strokeColorPresets');
        
        // Элементы для движения
        const movingWatermark = document.getElementById('movingWatermark');
        const motionSettings = document.getElementById('motionSettings');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const motionType = document.getElementById('motionType');
        const motionPresets = document.getElementById('motionPresets');
        const motionPreview = document.getElementById('motionPreview');
        const motionPreviewWatermark = document.getElementById('motionPreviewWatermark');
        
        // Элементы для загрузки медиа
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const mediaPreview = document.getElementById('mediaPreview');
        const videoPreview = document.getElementById('videoPreview');
        const videoContainer = document.getElementById('videoContainer');
        const noPreview = document.getElementById('noPreview');
        const changeMediaBtn = document.getElementById('changeMediaBtn');
        const mediaInfo = document.getElementById('mediaInfo');
        
        // Элементы для результата
        const processedMediaPreview = document.getElementById('processedMediaPreview');
        const processedVideoPreview = document.getElementById('processedVideoPreview');
        const processedVideoContainer = document.getElementById('processedVideoContainer');
        const noProcessedPreview = document.getElementById('noProcessedPreview');
        const downloadResultBtn = document.getElementById('downloadResultBtn');
        
        // === НОВЫЕ ЭЛЕМЕНТЫ ===
        const sendToBotBtn = document.getElementById('sendToBotBtn');
        const sendToChatBtn = document.getElementById('sendToChatBtn');
        const telegramInfo = document.getElementById('telegramInfo');
        const chatSelectionOverlay = document.getElementById('chatSelectionOverlay');
        const chatType = document.getElementById('chatType');
        const chatIdGroup = document.getElementById('chatIdGroup');
        const chatIdInput = document.getElementById('chatIdInput');
        const cancelChatSelectBtn = document.getElementById('cancelChatSelectBtn');
        const confirmSendBtn = document.getElementById('confirmSendBtn');
        
        // Элементы для сохраненных водяных знаков
        const savedWatermarksList = document.getElementById('savedWatermarksList');
        const saveCurrentWatermarkBtn = document.getElementById('saveCurrentWatermarkBtn');
        
        // Дополнительные элементы
        const processingOverlay = document.getElementById('processingOverlay');
        const processingText = document.getElementById('processingText');
        
        // Переменные состояния
        let currentStep = 1;
        let originalMedia = null;
        let processedMedia = null;
        let watermarkType = 'text';
        let watermarkImage = null;
        let position = 'bottom-right';
        let isVideo = false;
        let videoFrames = [];
        let videoDuration = 0;
        let originalFormat = '';
        let originalFileName = '';
        let savedWatermarks = [];
        
        // Цвета по умолчанию
        let textColor = '#FFFFFF';
        let strokeColor = '#000000';
        
        // Состояние водяного знака для движения
        let watermarkState = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            videoWidth: 0,
            videoHeight: 0,
            speed: 1,
            motionType: 'bounce',
            time: 0,
            amplitude: 100,
            frequency: 0.5,
            pathPoints: []
        };
        
        // Анимация предпросмотра движения
        let motionPreviewAnimation = null;
        let motionPreviewStartTime = 0;
        
        // Предустановленные цвета
        const colorPresets = {
            textColors: [
                '#FFFFFF', '#000000', '#FF0000', '#00FF00', '#0000FF',
                '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', '#800080',
                '#008000', '#FFC0CB', '#A52A2A', '#808080', '#FFD700'
            ],
            strokeColors: [
                '#000000', '#FFFFFF', '#333333', '#666666', '#999999',
                '#CCCCCC', '#FF0000', '#00FF00', '#0000FF', '#FFA500'
            ]
        };
        
        // Пресеты движения
        const motionPresetsData = [
            { name: 'Медленное плавание', speed: 3, type: 'bounce', amplitude: 50, frequency: 0.3 },
            { name: 'Быстрое кружение', speed: 8, type: 'circular', amplitude: 100, frequency: 1 },
            { name: 'Плавное по горизонтали', speed: 4, type: 'horizontal', amplitude: 80, frequency: 0.4 },
            { name: 'Плавное по вертикали', speed: 4, type: 'vertical', amplitude: 80, frequency: 0.4 },
            { name: 'Диагональный дрейф', speed: 5, type: 'diagonal', amplitude: 70, frequency: 0.5 },
            { name: 'Спиральный полет', speed: 6, type: 'spiral', amplitude: 120, frequency: 0.8 },
            { name: 'Случайный патруль', speed: 7, type: 'random', amplitude: 90, frequency: 0.6 },
            { name: 'Волнообразное', speed: 5, type: 'wave', amplitude: 60, frequency: 0.7 },
            { name: 'Восьмерка', speed: 6, type: 'figure8', amplitude: 80, frequency: 0.5 }
        ];
        
        // Инициализация
        init();
        
        function init() {
            // Загружаем сохраненные водяные знаки
            loadSavedWatermarks();
            
            // Инициализируем выбор цвета
            initColorPickers();
            
            // Инициализируем пресеты движения
            initMotionPresets();
            
            // Инициализируем предпросмотр движения
            initMotionPreview();
            
            // Навигация по шагам
            nextToStep2Btn.addEventListener('click', () => goToStep(2));
            backToStep1Btn.addEventListener('click', () => goToStep(1));
            backToStep2Btn.addEventListener('click', () => goToStep(2));
            applyWatermarkBtn.addEventListener('click', applyWatermark);
            processNewBtn.addEventListener('click', () => goToStep(2));
            resetAllBtn.addEventListener('click', resetAll);
            
            // Загрузка медиа (Шаг 2)
            uploadArea.addEventListener('click', () => fileInput.click());
            changeMediaBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleMediaUpload);
            
            // Настройки водяного знака (Шаг 1)
            textTypeOption.addEventListener('click', () => setWatermarkType('text'));
            imageTypeOption.addEventListener('click', () => setWatermarkType('image'));
            watermarkUploadArea.addEventListener('click', () => watermarkImageInput.click());
            watermarkImageInput.addEventListener('change', handleWatermarkImageUpload);
            
            opacitySlider.addEventListener('input', () => {
                opacityValue.textContent = `${opacitySlider.value}%`;
            });
            
            positionButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    positionButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    position = btn.dataset.position;
                });
            });
            
            // Настройки движения
            movingWatermark.addEventListener('change', () => {
                if (movingWatermark.checked) {
                    motionSettings.classList.add('active');
                    startMotionPreview();
                } else {
                    motionSettings.classList.remove('active');
                    stopMotionPreview();
                }
            });
            
            speedSlider.addEventListener('input', () => {
                speedValue.textContent = speedSlider.value;
            });
            
            motionType.addEventListener('change', () => {
                // Обновляем предпросмотр при изменении типа движения
                if (movingWatermark.checked) {
                    startMotionPreview();
                }
            });
            
            // Сохранение водяного знака
            saveCurrentWatermarkBtn.addEventListener('click', saveCurrentWatermark);
            
            // Скачивание результата
            downloadResultBtn.addEventListener('click', downloadResult);
            
            // === НОВЫЕ ОБРАБОТЧИКИ ===
            // Отправка боту
            sendToBotBtn.addEventListener('click', () => sendToTelegram('private'));
            
            // Отправка в группу/канал
            sendToChatBtn.addEventListener('click', showChatSelection);
            
            // Выбор чата
            chatType.addEventListener('change', handleChatTypeChange);
            cancelChatSelectBtn.addEventListener('click', hideChatSelection);
            confirmSendBtn.addEventListener('click', () => {
                const chatTypeValue = chatType.value;
                const chatId = chatIdInput.value.trim();
                sendToTelegram(chatTypeValue, chatId);
            });
        }
        
        // === НОВАЯ ФУНКЦИЯ: Отправка в Telegram ===
        async function sendToTelegram(type = 'private', chatId = null) {
            if (!processedMedia) return;
            
            showProcessing('Отправка в Telegram...');
            
            try {
                let targetChatId;
                
                if (type === 'private') {
                    // Получаем ID пользователя из WebApp
                    targetChatId = tg.initDataUnsafe?.user?.id;
                    if (!targetChatId) {
                        throw new Error('Не удалось получить ID пользователя');
                    }
                } else {
                    // Для группы/канала используем предоставленный ID
                    targetChatId = chatId;
                    if (!targetChatId) {
                        throw new Error('Введите ID чата/канала');
                    }
                }
                
                // Преобразуем медиа в Blob
                let blob;
                let fileName;
                
                if (isVideo) {
                    // Для видео
                    const response = await fetch(processedMedia.url);
                    blob = await response.blob();
                    fileName = `TgPosted_${Date.now()}.mp4`;
                } else {
                    // Для изображения
                    blob = dataURLtoBlob(processedMedia);
                    fileName = `TgPosted_${Date.now()}.jpg`;
                }
                
                // Создаем FormData
                const formData = new FormData();
                formData.append('chat_id', targetChatId);
                
                if (isVideo) {
                    formData.append('video', blob, fileName);
                } else {
                    formData.append('photo', blob, fileName);
                }
                
                // Отправляем файл через Telegram Bot API
                const method = isVideo ? 'sendVideo' : 'sendPhoto';
                const response = await fetch(`${API_URL}/${method}`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.ok) {
                    showSentMessage('Файл успешно отправлен в Telegram! ✅', false);
                    
                    // Закрываем WebApp через 2 секунды
                    setTimeout(() => {
                        tg.close();
                    }, 2000);
                } else {
                    throw new Error(result.description || 'Ошибка отправки');
                }
                
            } catch (error) {
                console.error('Ошибка отправки:', error);
                showSentMessage(`Ошибка: ${error.message} ❌`, true);
            } finally {
                hideProcessing();
                hideChatSelection();
            }
        }
        
        // === НОВАЯ ФУНКЦИЯ: Преобразование DataURL в Blob ===
        function dataURLtoBlob(dataurl) {
            const arr = dataurl.split(',');
            const mimeMatch = arr[0].match(/:(.*?);/);
            const mime = mimeMatch ? mimeMatch[1] : 'image/jpeg';
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            
            return new Blob([u8arr], { type: mime });
        }
        
        // === НОВАЯ ФУНКЦИЯ: Показать сообщение об отправке ===
        function showSentMessage(message, isError = false) {
            const existingMessage = document.querySelector('.sent-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `sent-message ${isError ? 'error' : ''}`;
            messageDiv.innerHTML = `
                <i class="fas ${isError ? 'fa-exclamation-circle' : 'fa-check-circle'}"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(messageDiv);
            
            // Автоматическое скрытие через 5 секунд
            setTimeout(() => {
                messageDiv.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 300);
            }, 5000);
        }
        
        // === НОВАЯ ФУНКЦИЯ: Показать выбор чата ===
        function showChatSelection() {
            chatSelectionOverlay.style.display = 'flex';
        }
        
        // === НОВАЯ ФУНКЦИЯ: Скрыть выбор чата ===
        function hideChatSelection() {
            chatSelectionOverlay.style.display = 'none';
            chatIdInput.value = '';
            chatIdGroup.style.display = 'none';
            chatType.value = 'private';
        }
        
        // === НОВАЯ ФУНКЦИЯ: Обработчик изменения типа чата ===
        function handleChatTypeChange() {
            if (chatType.value === 'private') {
                chatIdGroup.style.display = 'none';
                telegramInfo.style.display = 'flex';
            } else {
                chatIdGroup.style.display = 'block';
                telegramInfo.style.display = 'none';
            }
        }
        
        // === ОСТАЛЬНЫЕ ФУНКЦИИ (без изменений, но добавлены активации кнопок отправки) ===
        function goToStep(step) {
            // Обновляем индикатор шагов
            [step1, step2, step3].forEach(s => s.classList.remove('active', 'completed'));
            [step1Content, step2Content, step3Content].forEach(c => c.classList.remove('active'));
            
            // Отмечаем предыдущие шаги как выполненные
            for (let i = 1; i < step; i++) {
                document.getElementById(`step${i}`).classList.add('completed');
            }
            
            // Активируем текущий шаг
            document.getElementById(`step${step}`).classList.add('active');
            document.getElementById(`step${step}Content`).classList.add('active');
            
            currentStep = step;
            
            tg.HapticFeedback.impactOccurred('light');
        }
        
        function setWatermarkType(type) {
            watermarkType = type;
            
            if (type === 'text') {
                textTypeOption.classList.add('active');
                imageTypeOption.classList.remove('active');
                textWatermarkControl.classList.remove('hidden');
                imageWatermarkControl.classList.add('hidden');
            } else {
                textTypeOption.classList.remove('active');
                imageTypeOption.classList.add('active');
                textWatermarkControl.classList.add('hidden');
                imageWatermarkControl.classList.remove('hidden');
            }
        }
        
        function handleMediaUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const fileType = file.type;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                originalMedia = {
                    file: file,
                    url: e.target.result,
                    type: fileType
                };
                
                originalFormat = fileType;
                originalFileName = file.name;
                
                isVideo = fileType.startsWith('video/');
                
                if (isVideo) {
                    mediaPreview.classList.add('hidden');
                    videoContainer.classList.remove('hidden');
                    noPreview.classList.add('hidden');
                    
                    videoPreview.src = e.target.result;
                    videoPreview.load();
                    
                    videoPreview.onloadedmetadata = function() {
                        videoDuration = videoPreview.duration;
                        updateMediaInfo(file, videoDuration);
                        
                        const aspectRatio = videoPreview.videoWidth / videoPreview.videoHeight;
                        const maxWidth = 500;
                        const maxHeight = 400;
                        
                        if (aspectRatio > 1) {
                            videoContainer.style.width = '100%';
                            videoContainer.style.maxWidth = `${maxWidth}px`;
                        } else {
                            videoContainer.style.width = 'auto';
                            videoContainer.style.maxWidth = '300px';
                        }
                    };
                } else {
                    videoContainer.classList.add('hidden');
                    mediaPreview.classList.remove('hidden');
                    noPreview.classList.add('hidden');
                    
                    mediaPreview.src = e.target.result;
                    
                    const img = new Image();
                    img.onload = function() {
                        const aspectRatio = img.width / img.height;
                        if (aspectRatio > 1.5) {
                            mediaPreview.style.maxWidth = '100%';
                            mediaPreview.style.maxHeight = '400px';
                        } else {
                            mediaPreview.style.maxWidth = 'auto';
                            mediaPreview.style.maxHeight = '400px';
                        }
                    };
                    img.src = e.target.result;
                    
                    updateMediaInfo(file);
                }
                
                changeMediaBtn.classList.remove('hidden');
                applyWatermarkBtn.disabled = false;
                
                tg.HapticFeedback.impactOccurred('light');
            };
            
            reader.readAsDataURL(file);
        }
        
        function updateMediaInfo(file, duration = null) {
            const sizeInMB = (file.size / (1024 * 1024)).toFixed(2);
            let info = `Формат: ${originalFormat.split('/')[1].toUpperCase()} | Размер: ${sizeInMB} МБ`;
            
            if (duration) {
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                info += ` | Длительность: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            mediaInfo.textContent = info;
            mediaInfo.classList.remove('hidden');
        }
        
        function handleWatermarkImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                watermarkImage = new Image();
                watermarkImage.src = e.target.result;
                
                watermarkImagePreview.src = e.target.result;
                watermarkImagePreview.classList.remove('hidden');
            };
            
            reader.readAsDataURL(file);
        }
        
        function showProcessing(text) {
            processingText.textContent = text;
            processingOverlay.style.display = 'flex';
        }
        
        function hideProcessing() {
            processingOverlay.style.display = 'none';
        }
        
        async function applyWatermark() {
            if (!originalMedia) return;
            
            showProcessing('Наложение водяного знака...');
            applyWatermarkBtn.disabled = true;
            
            try {
                if (isVideo) {
                    await processVideo();
                } else {
                    await processImage();
                }
                
                // Переходим к шагу 3
                goToStep(3);
                downloadResultBtn.disabled = false;
                sendToBotBtn.disabled = false;
                sendToChatBtn.disabled = false;
                
                tg.HapticFeedback.impactOccurred('medium');
            } catch (error) {
                console.error('Ошибка обработки:', error);
                alert('Произошла ошибка при обработке. Попробуйте снова.');
            } finally {
                hideProcessing();
                applyWatermarkBtn.disabled = false;
            }
        }
        
        function processImage() {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    applyWatermarkToCanvas(ctx, canvas.width, canvas.height);
                    
                    let mimeType = originalFormat;
                    if (!mimeType || mimeType === 'image/gif') {
                        mimeType = 'image/png';
                    }
                    
                    try {
                        processedMedia = canvas.toDataURL(mimeType);
                    } catch (e) {
                        processedMedia = canvas.toDataURL('image/png');
                    }
                    
                    processedMediaPreview.src = processedMedia;
                    processedMediaPreview.classList.remove('hidden');
                    processedVideoContainer.classList.add('hidden');
                    noProcessedPreview.classList.add('hidden');
                    
                    const aspectRatio = img.width / img.height;
                    if (aspectRatio > 1.5) {
                        processedMediaPreview.style.maxWidth = '100%';
                        processedMediaPreview.style.maxHeight = '400px';
                    } else {
                        processedMediaPreview.style.maxWidth = 'auto';
                        processedMediaPreview.style.maxHeight = '400px';
                    }
                    
                    resolve();
                };
                
                img.src = originalMedia.url;
            });
        }
        
        function processVideo() {
            return new Promise((resolve) => {
                showProcessing('Обработка видео... Это может занять некоторое время');
                
                const tempVideo = document.createElement('video');
                tempVideo.src = originalMedia.url;
                tempVideo.muted = true;
                tempVideo.crossOrigin = 'anonymous';
                
                tempVideo.onloadeddata = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = tempVideo.videoWidth;
                    canvas.height = tempVideo.videoHeight;
                    
                    initializeWatermarkState(canvas.width, canvas.height);
                    
                    let fps = 30;
                    const totalFrames = Math.floor(videoDuration * fps);
                    let currentFrame = 0;
                    
                    videoFrames = [];
                    
                    function processFrame() {
                        tempVideo.currentTime = currentFrame / fps;
                        
                        tempVideo.onseeked = function() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
                            
                            applyWatermarkToCanvasWithMotion(
                                ctx, 
                                canvas.width, 
                                canvas.height, 
                                currentFrame / totalFrames
                            );
                            
                            videoFrames.push(canvas.toDataURL('image/jpeg', 1.0));
                            currentFrame++;
                            
                            processingText.textContent = `Обработка видео... ${Math.round((currentFrame / totalFrames) * 100)}%`;
                            
                            if (currentFrame < totalFrames) {
                                setTimeout(processFrame, 0);
                            } else {
                                createVideoFromFrames(fps).then(resolve);
                            }
                        };
                    }
                    
                    processFrame();
                };
                
                tempVideo.load();
            });
        }
        
        function initializeWatermarkState(videoWidth, videoHeight) {
            let watermarkWidth, watermarkHeight;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                const fontSize = Math.min(videoWidth, videoHeight) * 0.05;
                
                tempCtx.font = `bold ${fontSize}px Arial`;
                const text = watermarkText.value.trim();
                const textMetrics = tempCtx.measureText(text);
                
                watermarkWidth = textMetrics.width + fontSize;
                watermarkHeight = fontSize * 2;
                
                watermarkState.fontSize = fontSize;
            } else if (watermarkType === 'image' && watermarkImage) {
                watermarkWidth = videoWidth * 0.2;
                watermarkHeight = (watermarkImage.height / watermarkImage.width) * watermarkWidth;
            } else {
                watermarkWidth = videoWidth * 0.2;
                watermarkHeight = videoHeight * 0.1;
            }
            
            watermarkState.width = watermarkWidth;
            watermarkState.height = watermarkHeight;
            watermarkState.videoWidth = videoWidth;
            watermarkState.videoHeight = videoHeight;
            watermarkState.speed = parseInt(speedSlider.value) / 5;
            watermarkState.motionType = motionType.value;
            watermarkState.amplitude = 100;
            watermarkState.frequency = 0.5;
        }
        
        function applyWatermarkToCanvas(ctx, width, height) {
            const opacity = parseInt(opacitySlider.value) / 100;
            
            let x, y, watermarkWidth, watermarkHeight;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const fontSize = Math.min(width, height) * 0.05;
                ctx.font = `bold ${fontSize}px Arial`;
                const text = watermarkText.value.trim();
                const textMetrics = ctx.measureText(text);
                
                watermarkWidth = textMetrics.width + fontSize;
                watermarkHeight = fontSize * 2;
                
                switch(position) {
                    case 'top-left':
                        x = 10;
                        y = 10;
                        break;
                    case 'top-center':
                        x = (width - watermarkWidth) / 2;
                        y = 10;
                        break;
                    case 'top-right':
                        x = width - watermarkWidth - 10;
                        y = 10;
                        break;
                    case 'center-left':
                        x = 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center':
                        x = (width - watermarkWidth) / 2;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center-right':
                        x = width - watermarkWidth - 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = 10;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-center':
                        x = (width - watermarkWidth) / 2;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-right':
                        x = width - watermarkWidth - 10;
                        y = height - watermarkHeight - 10;
                        break;
                }
            } else if (watermarkType === 'image' && watermarkImage) {
                watermarkWidth = width * 0.2;
                watermarkHeight = (watermarkImage.height / watermarkImage.width) * watermarkWidth;
                
                switch(position) {
                    case 'top-left':
                        x = 10;
                        y = 10;
                        break;
                    case 'top-center':
                        x = (width - watermarkWidth) / 2;
                        y = 10;
                        break;
                    case 'top-right':
                        x = width - watermarkWidth - 10;
                        y = 10;
                        break;
                    case 'center-left':
                        x = 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center':
                        x = (width - watermarkWidth) / 2;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'center-right':
                        x = width - watermarkWidth - 10;
                        y = (height - watermarkHeight) / 2;
                        break;
                    case 'bottom-left':
                        x = 10;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-center':
                        x = (width - watermarkWidth) / 2;
                        y = height - watermarkHeight - 10;
                        break;
                    case 'bottom-right':
                        x = width - watermarkWidth - 10;
                        y = height - watermarkHeight - 10;
                        break;
                }
            }
            
            ctx.globalAlpha = opacity;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const text = watermarkText.value.trim();
                const fontSize = Math.min(width, height) * 0.05;
                ctx.font = `bold ${fontSize}px Arial`;
                
                ctx.strokeStyle = strokeColor;
                ctx.fillStyle = textColor;
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const centerX = x + (watermarkWidth / 2);
                const centerY = y + (watermarkHeight / 2);
                
                ctx.strokeText(text, centerX, centerY);
                ctx.fillText(text, centerX, centerY);
                
            } else if (watermarkType === 'image' && watermarkImage) {
                ctx.drawImage(watermarkImage, x, y, watermarkWidth, watermarkHeight);
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function applyWatermarkToCanvasWithMotion(ctx, width, height, progress) {
            const opacity = parseInt(opacitySlider.value) / 100;
            
            if (!movingWatermark.checked) {
                applyWatermarkToCanvas(ctx, width, height);
                return;
            }
            
            const time = progress * 60;
            const pos = calculateMotionPosition(
                time,
                width,
                height,
                watermarkState.width,
                watermarkState.height,
                watermarkState.speed,
                watermarkState.motionType,
                watermarkState.amplitude,
                watermarkState.frequency
            );
            
            let x = Math.max(0, Math.min(width - watermarkState.width, pos.x));
            let y = Math.max(0, Math.min(height - watermarkState.height, pos.y));
            
            ctx.globalAlpha = opacity;
            
            if (watermarkType === 'text' && watermarkText.value.trim()) {
                const text = watermarkText.value.trim();
                
                if (watermarkState.fontSize) {
                    ctx.font = `bold ${watermarkState.fontSize}px Arial`;
                } else {
                    const fontSize = Math.min(width, height) * 0.05;
                    ctx.font = `bold ${fontSize}px Arial`;
                }
                
                ctx.strokeStyle = strokeColor;
                ctx.fillStyle = textColor;
                ctx.lineWidth = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const centerX = x + (watermarkState.width / 2);
                const centerY = y + (watermarkState.height / 2);
                
                ctx.strokeText(text, centerX, centerY);
                ctx.fillText(text, centerX, centerY);
                
            } else if (watermarkType === 'image' && watermarkImage) {
                ctx.drawImage(watermarkImage, x, y, watermarkState.width, watermarkState.height);
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function calculateMotionPosition(time, width, height, wmWidth, wmHeight, speed, motionType, amplitude, frequency) {
            const maxX = width - wmWidth;
            const maxY = height - wmHeight;
            
            const t = time * speed;
            
            switch(motionType) {
                case 'bounce':
                    const bounceX = (Math.sin(t * frequency) * 0.5 + 0.5) * maxX;
                    const bounceY = (Math.cos(t * frequency * 0.7) * 0.5 + 0.5) * maxY;
                    return {
                        x: Math.max(0, Math.min(maxX, bounceX)),
                        y: Math.max(0, Math.min(maxY, bounceY))
                    };
                    
                case 'circular':
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const radius = Math.min(maxX, maxY) * 0.4;
                    const angle = t * frequency;
                    
                    return {
                        x: centerX + Math.cos(angle) * radius - wmWidth / 2,
                        y: centerY + Math.sin(angle) * radius - wmHeight / 2
                    };
                    
                case 'horizontal':
                    const hProgress = (Math.sin(t * frequency) * 0.5 + 0.5);
                    return {
                        x: hProgress * maxX,
                        y: height / 2 - wmHeight / 2
                    };
                    
                case 'vertical':
                    const vProgress = (Math.sin(t * frequency) * 0.5 + 0.5);
                    return {
                        x: width / 2 - wmWidth / 2,
                        y: vProgress * maxY
                    };
                    
                case 'diagonal':
                    const diagProgress = (Math.sin(t * frequency) * 0.5 + 0.5);
                    return {
                        x: diagProgress * maxX,
                        y: diagProgress * maxY
                    };
                    
                case 'spiral':
                    const spiralCenterX = width / 2;
                    const spiralCenterY = height / 2;
                    const spiralAngle = t * frequency;
                    const spiralRadius = (t % 10) / 10 * Math.min(maxX, maxY) * 0.5;
                    
                    return {
                        x: spiralCenterX + Math.cos(spiralAngle) * spiralRadius - wmWidth / 2,
                        y: spiralCenterY + Math.sin(spiralAngle) * spiralRadius - wmHeight / 2
                    };
                    
                case 'random':
                    const randomX = (Math.sin(t * 0.3) * 0.5 + 0.5) * maxX;
                    const randomY = (Math.cos(t * 0.4) * 0.5 + 0.5) * maxY;
                    return {
                        x: Math.max(0, Math.min(maxX, randomX)),
                        y: Math.max(0, Math.min(maxY, randomY))
                    };
                    
                case 'wave':
                    const waveX = (t * 0.5) % maxX;
                    const waveY = Math.sin(t * frequency) * amplitude + height / 2 - wmHeight / 2;
                    
                    return {
                        x: waveX,
                        y: Math.max(0, Math.min(maxY, waveY))
                    };
                    
                case 'figure8':
                    const scale = Math.min(width, height) * 0.3;
                    const figure8X = Math.sin(t * frequency) * scale + width / 2 - wmWidth / 2;
                    const figure8Y = Math.sin(t * frequency * 2) * scale * 0.5 + height / 2 - wmHeight / 2;
                    
                    return {
                        x: Math.max(0, Math.min(maxX, figure8X)),
                        y: Math.max(0, Math.min(maxY, figure8Y))
                    };
                    
                default:
                    return { x: 0, y: 0 };
            }
        }
        
        function createVideoFromFrames(fps) {
            return new Promise((resolve) => {
                showProcessing('Создание видео...');
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = videoPreview.videoWidth;
                canvas.height = videoPreview.videoHeight;
                
                const stream = canvas.captureStream(fps);
                
                let mimeType = 'video/webm;codecs=vp9';
                if (originalFormat.includes('mp4') && MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.42E01E')) {
                    mimeType = 'video/mp4;codecs=avc1.42E01E';
                }
                
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000
                });
                
                const chunks = [];
                
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = function() {
                    const blob = new Blob(chunks, { 
                        type: mimeType.split(';')[0]
                    });
                    const url = URL.createObjectURL(blob);
                    processedMedia = {
                        url: url,
                        type: mimeType.split(';')[0]
                    };
                    
                    processedVideoPreview.src = url;
                    processedVideoContainer.classList.remove('hidden');
                    processedMediaPreview.classList.add('hidden');
                    noProcessedPreview.classList.add('hidden');
                    
                    const aspectRatio = videoPreview.videoWidth / videoPreview.videoHeight;
                    const maxWidth = 500;
                    
                    if (aspectRatio > 1) {
                        processedVideoContainer.style.width = '100%';
                        processedVideoContainer.style.maxWidth = `${maxWidth}px`;
                    } else {
                        processedVideoContainer.style.width = 'auto';
                        processedVideoContainer.style.maxWidth = '300px';
                    }
                    
                    resolve();
                };
                
                mediaRecorder.start();
                
                let frameIndex = 0;
                const totalFrames = videoFrames.length;
                
                function drawNextFrame() {
                    if (frameIndex >= totalFrames) {
                        mediaRecorder.stop();
                        return;
                    }
                    
                    const img = new Image();
                    img.onload = function() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        frameIndex++;
                        setTimeout(drawNextFrame, 1000 / fps);
                    };
                    
                    img.src = videoFrames[frameIndex];
                }
                
                drawNextFrame();
            });
        }
        
        function downloadResult() {
            if (!processedMedia) return;
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const originalName = originalFileName.substring(0, originalFileName.lastIndexOf('.'));
            
            if (isVideo) {
                link.href = processedMedia.url;
                let extension = 'webm';
                if (processedMedia.type === 'video/mp4') {
                    extension = 'mp4';
                }
                link.download = `TgPosted_${originalName}_${timestamp}.${extension}`;
            } else {
                link.href = processedMedia;
                let extension = 'png';
                if (originalFormat.includes('jpeg') || originalFormat.includes('jpg')) {
                    extension = 'jpg';
                } else if (originalFormat.includes('png')) {
                    extension = 'png';
                } else if (originalFormat.includes('gif')) {
                    extension = 'gif';
                }
                link.download = `TgPosted_${originalName}_${timestamp}.${extension}`;
            }
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            tg.HapticFeedback.impactOccurred('medium');
        }
        
        // === ФУНКЦИИ ДЛЯ ЦВЕТОВ (без изменений) ===
        function initColorPickers() {
            // ... (без изменений)
        }
        
        function updateColorValues() {
            // ... (без изменений)
        }
        
        function highlightPreset(presetElement, container) {
            // ... (без изменений)
        }
        
        function highlightPresetByColor(color, container) {
            // ... (без изменений)
        }
        
        // === ФУНКЦИИ ДЛЯ СОХРАНЕННЫХ ВОДЯНЫХ ЗНАКОВ (без изменений) ===
        function loadSavedWatermarks() {
            // ... (без изменений)
        }
        
        function renderSavedWatermarksList() {
            // ... (без изменений)
        }
        
        function loadSavedWatermark(index) {
            // ... (без изменений)
        }
        
        function saveCurrentWatermark() {
            // ... (без изменений)
        }
        
        function deleteSavedWatermark(index) {
            // ... (без изменений)
        }
        
        // === ФУНКЦИИ ДЛЯ ДВИЖЕНИЯ (без изменений) ===
        function initMotionPresets() {
            // ... (без изменений)
        }
        
        function initMotionPreview() {
            // ... (без изменений)
        }
        
        function startMotionPreview() {
            // ... (без изменений)
        }
        
        function stopMotionPreview() {
            // ... (без изменений)
        }
        
        // === ФУНКЦИЯ СБРОСА (с добавлением сброса кнопок отправки) ===
        function resetAll() {
            currentStep = 1;
            goToStep(1);
            
            originalMedia = null;
            processedMedia = null;
            watermarkImage = null;
            videoFrames = [];
            
            mediaPreview.classList.add('hidden');
            videoContainer.classList.add('hidden');
            noPreview.classList.remove('hidden');
            changeMediaBtn.classList.add('hidden');
            mediaInfo.classList.add('hidden');
            
            processedMediaPreview.classList.add('hidden');
            processedVideoContainer.classList.add('hidden');
            noProcessedPreview.classList.remove('hidden');
            
            watermarkImagePreview.classList.add('hidden');
            watermarkImageInput.value = '';
            fileInput.value = '';
            
            applyWatermarkBtn.disabled = true;
            downloadResultBtn.disabled = true;
            sendToBotBtn.disabled = true;
            sendToChatBtn.disabled = true;
            
            watermarkText.value = '@TgPosted';
            opacitySlider.value = 70;
            opacityValue.textContent = '70%';
            
            movingWatermark.checked = false;
            motionSettings.classList.remove('active');
            speedSlider.value = 5;
            speedValue.textContent = '5';
            motionType.value = 'bounce';
            stopMotionPreview();
            
            document.querySelectorAll('.motion-preset').forEach(p => {
                p.classList.remove('active');
            });
            
            positionButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector('.position-btn[data-position="bottom-right"]').classList.add('active');
            position = 'bottom-right';
            
            textColor = '#FFFFFF';
            strokeColor = '#000000';
            textColorPicker.value = textColor;
            strokeColorPicker.value = strokeColor;
            updateColorValues();
            highlightPresetByColor(textColor, textColorPresets);
            highlightPresetByColor(strokeColor, strokeColorPresets);
            
            setWatermarkType('text');
            
            document.querySelectorAll('.saved-watermark-item').forEach(item => {
                item.classList.remove('active');
            });
            
            hideChatSelection();
            
            tg.HapticFeedback.impactOccurred('light');
        }
        
        // === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ (без изменений) ===
        function showNotification(message) {
            // ... (без изменений)
        }
    </script>
</body>
</html>
